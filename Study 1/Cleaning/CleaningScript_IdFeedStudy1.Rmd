---
title: "R Notebook"
output: html_notebook
---

```{r}
library(igraph)
library(tidyverse)
library(careless)
```

```{r}
library(devtools)
source_url("https://raw.githubusercontent.com/JacobElder/MiscellaneousR/master/assortativityNA.R")
numbers_only <- function(x) !grepl("\\D", x)
```

```{r}
rawFirst <- read.csv("~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Input/idFeedRaw1.csv", header = T)
rawFirst <- rawFirst[!as.numeric(duplicated(rawFirst$id)),]

rawFirst<-rename(rawFirst, "I8_Sims_" = contains("I9_Sims")) # temporary fix

rawSec <- read.csv("~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Input/idFeedRaw2.csv", header = T)
rawSec <- rawSec[!as.numeric(duplicated(rawSec$id)),]

rawSec <- rename(rawSec, A_I8 = A_l8)

tAdjMatP <- read.csv("~/Google Drive/Volumes/Research Project/Trait Network_Behaviral/generating network/output/adjacencyMatrix_p.csv")

tAdjMatN <- read.csv("~/Google Drive/Volumes/Research Project/Trait Network_Behaviral/generating network/output/adjacencyMatrix_n.csv")

posTraits <- read.csv("~/Google Drive/Volumes/Research Project/Trait Network_Behaviral/generating network/output/allPosCents.csv")

negTraits <- read.csv("~/Google Drive/Volumes/Research Project/Trait Network_Behaviral/generating network/output/allNegCents.csv")
```

```{r}
setwd("~/Google Drive/Volumes/")
posDf <- read.csv("./Research Project/Trait Network_Behaviral/generating network/output/adjacencyMatrix_p.csv")
posMat <- as.matrix(posDf)
posGraph <- graph.adjacency(posMat)
negDf <- read.csv("./Research Project/Trait Network_Behaviral/generating network/output/adjacencyMatrix_n.csv")
negMat <- as.matrix(negDf)
negGraph <- graph.adjacency(negMat)
```

```{r}
is.emptyString <- function(input){
  if(input==''){
    output <- TRUE
  }else{
    output <- FALSE
  }
  return(output)
}
rawFirst$identity[which(rawFirst$identity!="Asian" & rawFirst$identity!="Latino")]
rawFirst <- subset(rawFirst, rawFirst$identity=="Asian" | rawFirst$identity=="Latino")

rawidSubs <- grep("Identity.Nominations_1",colnames(rawFirst)):grep("Identity.Nominations_41",colnames(rawFirst))
emptyRows<-apply(rawFirst[rawidSubs], c(1,2), is.emptyString)
rawFirst<-rawFirst[!apply(emptyRows, 1, all),]
missRows <- rowSums(apply(select(rawSec, Accurate:Worrier), c(1,2), is.na))
badRows <- missRows > 30
rawSec <- rawSec[!badRows,]

rawFirst <- rawFirst[rawFirst$id!=47001,]
rawSec <- rawSec[rawSec$id!=47001,]

rawSec$remove <- ifelse(rawSec$Serious1 < 5 | rawSec$Serious2 < 5 | rawSec$Usable == 2 | rawSec$Off7 == 3, 1, 0)
rawSec <- rawSec[rawSec$remove!=1,]

rawFirst <- rawFirst[numbers_only(rawFirst$id),]
rawSec <- rawSec[numbers_only(rawSec$id),]

rawFirst <- rawFirst[!is.na(rawFirst$id),]
rawSec <- rawSec[!is.na(rawSec$id),]
```

# Careless responding

```{r}
# idInds <- grep("I_Race",colnames(rawSec)):grep("U_Pol",colnames(rawSec))
# trInds <- grep("Accurate",colnames(rawSec)):grep("Worrier",colnames(rawSec))
# careless_long <- longstring(rawSec[idInds])
# propIdentical1 <- careless_long/length(idInds)
# identicalID <- propIdentical1>.30
# 
# careless_long <- longstring(rawSec[trInds])
# propIdentical2 <- careless_long/length(trInds)
# identicalTR <- propIdentical2>.04
# 
# careless_irv <- irv(rawSec[idInds], split = TRUE, num.split = 3)
# carelessID <- careless_irv$irvTotal > mean(careless_irv$irvTotal)+sd(careless_irv$irvTotal)*1
# 
# careless_irv <- irv(rawSec[trInds], split = TRUE, num.split = 10)
# carelessTR <- careless_irv$irvTotal > mean(careless_irv$irvTotal)+sd(careless_irv$irvTotal)*1
# 
# synonym <- psychsyn(rawSec[trInds], critval = .60) < mean(abs(psychant(rawSec[trInds], critval = .60)),na.rm=T) - sd(psychant(rawSec[trInds], critval = .60),na.rm=T)
# 
# antonym <- abs(psychant(rawSec[trInds], critval = .30)) < mean(abs(psychant(rawSec[trInds], critval = .60)),na.rm=T) - sd(abs(psychant(rawSec[trInds], critval = .60)),na.rm=T)
# 
# carelessDf <- data.frame(identicalID, identicalTR, carelessID, carelessTR, synonym, antonym)
# rowSums(carelessDf)
# 
# rawSec <- rawSec[rowSums(carelessDf)<2,]
```

```{r}
demos <-rawFirst %>% select(id, Age:Educ)
```

```{r}
idMat <- matrix(NA,ncol=9,nrow=nrow(rawFirst))
for(n in 1:nrow(rawFirst) ){
  identities <- rawFirst %>% 
    select(Identity.Nominations_1:Identity.Nominations_41) %>%
    slice(n) %>%
    as_vector()
  
  idIndices <- identities %>%
    map(is.emptyString) %>%
    unlist()
  
  identities[idIndices] <- NA
  
  idMat[n,] <- c(rawFirst$id[n], identities)
  
  
    
}

idMat <- as_tibble(idMat)
colnames(idMat) <- c("subID",paste0("I",1:8))
```

# Generate identity networks

```{r}
uIds <- unique(rawFirst$id)
# column names
idSubs <- rawFirst %>%
  select(contains("_Relations"))
for(n in 1:nrow(rawFirst)){
  i <- rawFirst$id[n]
  
  idNames <- idMat[idMat$subID==i,2:9] %>% as_vector() %>% na.omit()
  numIdentities <- sum(!is.na(idMat[idMat$subID==i,2:9]))
  
  # subset subject row
  subDf <- rawFirst[rawFirst$id==i,]
  # generate empty matrix
  subMat <- matrix(data = 0, nrow = numIdentities, ncol = numIdentities)
  subMatW <- matrix(data = 0, nrow = numIdentities, ncol = numIdentities)
  for(c in 1:numIdentities){
    # subset identity "c"
    j <- idSubs[n,c]
    # split words by comma
    selectWord <-strsplit(as.character(idSubs[n,c][[1]]),",") 
    # which column index are select identities
    ######rowSub <-which(idNames %in% selectWord[[1]])
    # populate 1s for select identities in row
    subMat[c,as.numeric(unlist(selectWord))] <- 1 # Unweighted matrix
    diag(subMat) <- 0 # Set diagonal to 0s if participants nominated any self-connections
    subMatW[c,as.numeric(unlist(selectWord))]  <- (rawFirst[n,paste0("I",c,"_Sims_",as.numeric(unlist(selectWord) ))] ) # Weighted matrix
    # if participant didn't indicate weight, replace with 0
    subMatW[is.na(subMatW)] <- 0
    # Flipped direction of fraction so more overlap is closer between identities
    
    diag(subMatW) <- 0 # Set diagonal to 0s if participants nominated any self-connections
}
  rownames(subMat) <- idNames
  colnames(subMat) <- idNames
  
  rownames(subMatW) <- idNames
  colnames(subMatW) <- idNames

    # convert to graph
  subGraph <- graph.adjacency(subMat)
  subGraphW <- graph.adjacency(subMatW, weighted = T)
  # label
  assign(paste0("subIMat.",i),subMat)
  assign(paste0("subIGraph.",i),subGraph)
  
  assign(paste0(".",i),subMatW)
  assign(paste0("subIGraphW.",i),subGraphW)
}

```

```{r}
idSubs <- grep("I1_PosTraits",colnames(rawFirst)):grep("I8_NegTraits",colnames(rawFirst))

for(n in 1:nrow(rawFirst)){
   i <- rawFirst$id[n]
  
  # subset subject
  subDf <- rawFirst[rawFirst$id==i,]
  
  idNames <- idMat[idMat$subID==i,2:9] %>% as_vector() %>% na.omit()
  numIdentities <- sum(!is.na(idMat[idMat$subID==i,2:9]))
  
  # create empty matrices 148 traits causing 8 identities because traits don't cause identities
  tAdjMatPI <- as.matrix(cbind(matrix(data=0, ncol=numIdentities, nrow=148), tAdjMatP))
  tAdjMatNI <- as.matrix(cbind(matrix(data=0, ncol=numIdentities, nrow=148), tAdjMatN))
  # 8 identities causing 148 traits for each valence
  subMatP <- matrix(data = 0, nrow = numIdentities, ncol = 148)
  subMatN <- matrix(data = 0, nrow = numIdentities, ncol = 148)
  identityMat <- get(paste0("subIMat.",i))
  identityMatW <- get(paste0("subIMatW.",i))
  subMatP <- cbind(identityMat, subMatP)
  subMatN <- cbind(identityMat, subMatN)
  # for each identity
  for(c in 1:numIdentities ){
    # extract trait nominations for identity c
    #traitsCols <- grep(idNames[c],colnames(rawFirst[idSubs]))
    traitsCols <- select(rawFirst[idSubs], contains(paste0("I",c,"_")))
    # first index is pos traits
    posCols <- traitsCols[n,1]
    # second index is neg traits
    negCols <- traitsCols[n,2]
    # split it
    selectWordP <- unlist(strsplit(as.character(posCols),","))
    # all traits need to be pushed up by quantity of identities because the matrix contains identities first
    selectWordP <-as.numeric(selectWordP) + numIdentities
    # populate with 1s for nominations
    subMatP[c , selectWordP] <- 1
    # do the same for negative
    selectWordN <- unlist(strsplit(as.character(negCols),","))
    selectWordN <-as.numeric(selectWordN) + numIdentities
    subMatN[c , selectWordN] <- 1
  }
  # bind empty matrices so it's with empty cells for traits causing identities
  subTPMat <- rbind(subMatP, tAdjMatPI)
  subTNMat <- rbind(subMatN, tAdjMatNI)
  # assign identities as first identity names and traits as the next 148 names
  colnames(subTPMat) <- c(idNames, posTraits$trait)
  # convert to graph
  subTPGraph <- graph.adjacency(subTPMat)
  # identities causing traits and identities causing identities matrix
  assign(paste0("subTPMat.",i),subTPMat)
  assign(paste0("subTPGraph.",i),subTPGraph)
  # generate identities causing pos traits only (neglect identities to identities)
  subTonlyPMat <- subTPMat
  # empty first matrix of 8x8
  subTonlyPMat[1:numIdentities,1:numIdentities] <- 0
  assign(paste0("subTonlyPMat.",i),subTonlyPMat)
  subTonlyPGraph <- graph.adjacency(subTonlyPMat)
  assign(paste0("subTonlyPGraph.",i),subTonlyPGraph)
  # generate identities causing pos traits only (neglect identities to identities and traits causing traits... only identities causing traits)
  subItoTonlyPMat <- subTPMat
  subItoTonlyPMat[1:numIdentities,1:numIdentities] <- 0
  subItoTonlyPMat[(numIdentities+1):nrow(subItoTonlyPMat),1:ncol(subItoTonlyPMat)] <- 0
  assign(paste0("subItoTonlyPMat.",i),subItoTonlyPMat)
  subItoTonlyPGraph <- graph.adjacency(subItoTonlyPMat)
  assign(paste0("subItoTonlyPGraph.",i),subItoTonlyPGraph)
  
  # do it again for negative
  colnames(subTNMat) <- c(idNames, negTraits$trait)
  subTNGraph <- graph.adjacency(subTNMat)
  assign(paste0("subTNMat.",i),subTNMat)
  assign(paste0("subTNGraph.",i),subTNGraph)
  subTonlyNMat <- subTNMat
  subTonlyNMat[1:numIdentities,1:numIdentities] <- 0
  assign(paste0("subTonlyNMat.",i),subTonlyNMat)
  subTonlyNGraph <- graph.adjacency(subTonlyNMat)
  assign(paste0("subTonlyNGraph.",i),subTonlyNGraph)
  subItoTonlyNMat <- subTNMat
  subItoTonlyNMat[1:numIdentities,1:numIdentities] <- 0
  subItoTonlyNMat[(numIdentities+1):nrow(subItoTonlyNMat),1:ncol(subItoTonlyNMat)] <- 0
  assign(paste0("subItoTonlyNMat.",i),subItoTonlyNMat)
  subItoTonlyNGraph <- graph.adjacency(subItoTonlyNMat)
  assign(paste0("subItoTonlyNGraph.",i),subItoTonlyNGraph)
  
  # combine the two matrices (don't repeat identities matrix which is first 8x8)
  if(numIdentities>1){
    subTFMat <- cbind(subMatP, subMatN[1:(numIdentities), (numIdentities+1):(numIdentities+148) ])
  }else{
    subTFMat <- c(subMatP, subMatN[1:(numIdentities), (numIdentities+1):(numIdentities+148) ])
  }
  
  # bind such that pos traits do not cause identities (148x8 of 0s), pos traits can cause pos traits, and pos traits cannot cause neg traits (148x148 of 0s)
  subTFMat <- rbind(subTFMat, as.matrix(data.frame(matrix(data=0, nrow=148, ncol=numIdentities ), tAdjMatP, matrix(data=0, nrow=148, ncol=148)) ))
  # bind such that neg traits do not cause identities (148x8 of 0s), neg traits cannot cause pos traits (148x148 of 0s), and neg traits can cause neg traits
  subTFMat <- rbind(subTFMat, as.matrix(data.frame(matrix(data=0, nrow=148, ncol=numIdentities ), matrix(data=0, nrow=148, ncol=148), tAdjMatN) ))
  colnames(subTFMat) <- c(idNames, posTraits$trait, negTraits$trait)
  subTFGraph <- graph.adjacency(subTFMat)
  assign(paste0("subTFMat.",i),subTFMat)
  assign(paste0("subTFGraph.",i),subTFGraph)
  # create identities to traits only matrix (neglecting identity-identity connections)
  subTonlyFMat <- subTFMat
  subTonlyFMat[1:numIdentities,1:numIdentities] <- 0
  assign(paste0("subTonlyFMat.",i),subTonlyFMat)
  subTonlyFGraph <- graph.adjacency(subTonlyFMat)
  assign(paste0("subTonlyFGraph.",i),subTonlyFGraph)
  # create identities to traits only matrix (neglecting identity-identity and trait causing trait connections)
  subItoTonlyFMat <- subTFMat
  subItoTonlyFMat[1:numIdentities,1:numIdentities] <- 0
  subItoTonlyFMat[(numIdentities+1):nrow(subItoTonlyFMat),1:ncol(subItoTonlyFMat)] <- 0
  assign(paste0("subItoTonlyFMat.",i),subItoTonlyFMat)
  subItoTonlyFGraph <- graph.adjacency(subItoTonlyFMat)
  assign(paste0("subItoTonlyFGraph.",i),subItoTonlyFGraph)
  
}
```

```{r warning=FALSE}

for(n in 1:nrow(rawSec)){
  # n is 19 for 57517
  i <- rawSec$id[n]

  idNames <- idMat[idMat$subID==i,2:9] %>% as_vector() %>% na.omit()
  numIdentities <- sum(!is.na(idMat[idMat$subID==i,2:9]))
    
    # identity to identity causing
    curGraph <- get(paste0("subIGraph.",i))
    # identity to identity causing
    curGraphW <- get(paste0("subIGraphW.",i))
    
    if(numIdentities>1){
    
    I2Ioutdeg <- degree(curGraph, mode="out")
    # identity to identity, receiving
    I2Iindeg <- degree(curGraph, mode="in")
    # identity to identity, all
    I2Ideg <- degree(curGraph, mode="all")
    # identity to identity, local trans
    I2Itrans <- transitivity(curGraph, "localundirected")
    # identity to identity, betweenness
    I2Ibet <- betweenness(curGraph, directed = F)
    # identity to identity, closeness
    I2Iclose <- closeness(curGraph, mode = "all", normalized = T)
    # identity to identity, eigen.vector
    I2Ieigen <- eigen_centrality(curGraph, directed = F)$vector
    
    # identity to identity network total edges
    idEdgT <- ecount(curGraph)
    # density
    density <- edge_density(curGraph)
    # average distance
    aveDist <- mean_distance(curGraph)
    # clustering coefficient
    idTrans <- transitivity(curGraph, "global")
    # small worldness
    # global efficiency
    globEff <- brainGraph::efficiency(curGraph, type = "global")
    
    # assortativity of identification
    V(curGraph)$ident <- rawSec[rawSec$id==i, paste0("I_I",1:numIdentities)]
    idStrengHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$ident)+rnorm(1, 0, .00001), directed=F)
    # of positivity
    V(curGraph)$pos <- rawSec[rawSec$id==i, paste0("P_I",1:numIdentities)]
    idPosHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$pos)+rnorm(1, 0, .00001), directed=F)
    # of stigma
    V(curGraph)$Stig <- rawSec[rawSec$id==i, paste0("St_I",1:numIdentities)]
    idStigHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$Stig)+rnorm(1, 0, .00001), directed=F)
    # of size to school
    V(curGraph)$SzS <- rawSec[rawSec$id==i, paste0("Sz_I",1:numIdentities,"_1")]
    idSzSHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$SzS)+rnorm(1, 0, .00001), directed=F)
    # of size to U.S.
    V(curGraph)$SzU <- rawSec[rawSec$id==i, paste0("Sz_I",1:numIdentities,"_13")]
    idSzUHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$SzU)+rnorm(1, 0, .00001), directed=F)
    # of size difference
    V(curGraph)$SzD <- as.numeric(V(curGraph)$SzS) - as.numeric(V(curGraph)$SzU)
    idSzDHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$SzD)+rnorm(1, 0, .00001), directed=F)
    # of inclusion
    V(curGraph)$inclus <- rawSec[rawSec$id==i, paste0("A_I",1:numIdentities)]
    idInclusHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$inclus)+rnorm(1, 0, .00001), directed=F)
    # of differentiation
    V(curGraph)$differ <- rawSec[rawSec$id==i, paste0("D_I",1:numIdentities)]
    idDifferHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$differ)+rnorm(1, 0, .00001), directed=F)
    
    # global similarity of identity network
    idCommGlob <- (similarity(curGraph, method = "dice"))%>% .[lower.tri(.)] %>% mean()
    # each node's distance from race
    idCommRaceN <-similarity(curGraph, method = "dice")[1,]
    # identity-node similarity
    idCommNod <- rowMeans(similarity(curGraph, method = "dice")[1:numIdentities,1:numIdentities])
    # mean similarity from race (as feedback targeted at race)
    idCommRaceM <- mean(similarity(curGraph, method = "dice")[1,],na.rm=T)
    
    distanceMat <- distances(curGraph)
    distanceMat[is.infinite(distanceMat)] <- NA
    # nodal distance of identity network
    idDistNod <- rowMeans(distanceMat, na.rm=T)
    # each node's distance from race (as feedback targeted at race)
    idDistRaceN <- distanceMat[1,]
    # global distance of identity network
    idDistGlob <- distanceMat %>% .[lower.tri(.)] %>% mean(na.rm=T)
    # mean distance from race (as feedback targeted at race)
    idDistRaceM <- mean(distanceMat[1,],na.rm=T)
    
    distanceMat <- distances(curGraphW)
    distanceMat[is.infinite(distanceMat)] <- NA
    # nodal distance of identity network (weighted)
    idDistNodW <- rowMeans(distanceMat, na.rm=T)
    # mean distance from race (as feedback targeted at race)
    idDistRaceNW <- distanceMat[1,]
    # global distance of identity network (weighted)
    idDistGlobW <- distanceMat %>% .[lower.tri(.)] %>% mean(na.rm=T)
    # mean distance from race (as feedback targeted at race)
    idDistRaceMW <- mean(distanceMat[1,],na.rm=T)
    }
    # }else{
    #   idDistGlob=NA
    #   idDistRaceM=NA
    #   idDistNodW=NA
    #   idDistRaceNW=NA
    #   idDistGlobW=NA
    #   idDistRaceMW=NA
    # }
    
    # identity to traits, valence combined
    # use identity to traits only network
    #curGraph <- get(paste0("subTonlyFGraph.",i))
    # use identity to traits only network
    curGraph <- get(paste0("subItoTonlyFGraph.",i))
    cI2Tdeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    cI2T.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    cI2T.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    cI2T.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    cI2T.Hub <- hub_score(curGraph, scale = TRUE)$vector
    # identity to traits and identities, valence combined
    curGraph <- get(paste0("subTFGraph.",i))
    cI2Adeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    cI2A.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    cI2A.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    cI2A.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    cI2A.Hub <- hub_score(curGraph, scale = TRUE)$vector
    
    # global similarity of identity network (traits they have in common)
    traitCommGlob <- (similarity(curGraph, method = "dice"))%>% .[lower.tri(.)] %>% mean()
    if(numIdentities>1){
      # identity-node similarity
      traitCommNod <- rowMeans(similarity(curGraph, method = "dice")[1:numIdentities,1:numIdentities])
    }else{
      traitCommNod <- mean(similarity(curGraph, method = "dice")[1:numIdentities,1:numIdentities])
    }
    # mean similarity from race (as feedback targeted at race)
    traitCommRace <- mean(similarity(curGraph, method = "dice")[1,],na.rm=T)
    
    distanceMat <- distances(curGraph)
    distanceMat[is.infinite(distanceMat)] <- NA
    if(numIdentities>1){
      # nodal distance of traitentity network
      traitDistNod <- rowMeans(distanceMat[1:numIdentities,1:numIdentities],na.rm=T)
    }else{
      traitDistNod <- mean(distanceMat, na.rm=T)
    }
    
    # global distance of traitentity network
    traitDistGlob <- distanceMat %>% .[lower.tri(.)] %>% mean(na.rm=T)
    # mean distance from race (as feedback targeted at race)
    traitDistRaceP <- mean(distanceMat[1,(numIdentities+1):(numIdentities+148)],na.rm=T)
    # mean distance from race (as feedback targeted at race)
    traitDistRaceN <- mean(distanceMat[1,(numIdentities+1+148):(numIdentities+148+148)],na.rm=T)
    
    # identity to traits, positive
    # use identity to traits only network
    #curGraph <- get(paste0("subTonlyPGraph.",i))
    # use identity to traits only network
    curGraph <- get(paste0("subItoTonlyPGraph.",i))
    pI2Tdeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    pI2T.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    pI2T.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    pI2T.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    pI2T.Hub <- hub_score(curGraph, scale = TRUE)$vector
    # identity to traits and identities, positive
    curGraph <- get(paste0("subTPGraph.",i))
    pI2Adeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    pI2A.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    pI2A.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    pI2A.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    pI2A.Hub <- hub_score(curGraph, scale = TRUE)$vector
    
    # identity to traits, negative
    # use identity to traits and traits to traits network
    #curGraph <- get(paste0("subTonlyNGraph.",i))
    # use identity to traits only network
    curGraph <- get(paste0("subItoTonlyNGraph.",i))
    nI2Tdeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    nI2T.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    nI2T.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    nI2T.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    nI2T.Hub <- hub_score(curGraph, scale = TRUE)$vector
    # identity to traits and identities, negative
    curGraph <- get(paste0("subTNGraph.",i))
    nI2Adeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    nI2A.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    nI2A.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    nI2A.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    nI2A.Hub <- hub_score(curGraph, scale = TRUE)$vector
    
    # traits receiving identities
    curGraph <- get(paste0("subItoTonlyFGraph.",i))
    IdIn <- degree(curGraph, mode="in")

    if(numIdentities>1){
  
    x1 <- cbind(subID=rep(i,numIdentities), id=idNames, idcode = 1:numIdentities, I2Ioutdeg = I2Ioutdeg[1:numIdentities], I2Iindeg = I2Iindeg[1:numIdentities], I2Ideg = I2Ideg[1:numIdentities],
                cI2Tdeg=cI2Tdeg[1:numIdentities], cI2Adeg=cI2Adeg[1:numIdentities],
                                    pI2Tdeg=pI2Tdeg[1:numIdentities], pI2Adeg=pI2Adeg[1:numIdentities], nI2Tdeg=nI2Tdeg[1:numIdentities],
                nI2Adeg=nI2Adeg[1:numIdentities], I2Itrans=I2Itrans[1:numIdentities], I2Ibet=I2Ibet[1:numIdentities], I2Iclose=I2Iclose[1:numIdentities],
                                   I2Ieigen=I2Ieigen[1:numIdentities], cI2T.Trans=cI2T.Trans[1:numIdentities], cI2T.Bet=cI2T.Bet[1:numIdentities],
                cI2T.Clos=cI2T.Clos[1:numIdentities], cI2A.Trans=cI2A.Trans[1:numIdentities], cI2A.Bet=cI2A.Bet[1:numIdentities],
                                   cI2A.Clos=cI2A.Clos[1:numIdentities], pI2T.Trans=pI2T.Trans[1:numIdentities], pI2T.Bet=pI2T.Bet[1:numIdentities],
                pI2T.Clos=pI2T.Clos[1:numIdentities], pI2A.Trans=pI2A.Trans[1:numIdentities], pI2A.Bet=pI2A.Bet[1:numIdentities],
                                   pI2A.Clos=pI2A.Clos[1:numIdentities], nI2T.Trans=nI2T.Trans[1:numIdentities], nI2T.Bet=nI2T.Bet[1:numIdentities],
                nI2T.Clos=nI2T.Clos[1:numIdentities], nI2A.Trans=nI2A.Trans[1:numIdentities], nI2A.Bet=nI2A.Bet[1:numIdentities],
                                   nI2A.Clos=nI2A.Clos[1:numIdentities], idCommNod, traitCommNod, idCommRaceN, idDistNod,
                idDistRaceN, idDistNodW, idDistRaceNW,
                cI2A.Hub=cI2A.Hub[1:numIdentities],
                cI2T.Hub=cI2T.Hub[1:numIdentities], pI2A.Hub=pI2A.Hub[1:numIdentities],
                                   pI2T.Hub=pI2T.Hub[1:numIdentities], nI2A.Hub=nI2A.Hub[1:numIdentities], nI2T.Hub=nI2T.Hub[1:numIdentities])
    
    }else{
      x1 <- cbind(subID=rep(i,numIdentities), id=idNames, idcode = 1:numIdentities)
      x1 <- c(x1,
                  rep(NA,(ncol(idDf)-3) ) )
      names(x1)<-colnames(idDf)
    }
    
  if(n==1){
    idDf <- matrix(nrow=0,ncol=ncol(x1))
    idDf <- rbind(idDf, x1)
  }else{
    idDf <- rbind(idDf, x1)
  }
  
     x2 <- cbind(subID = rep(i,296), traits = c(posTraits$trait, negTraits$trait), idNum = numIdentities, IdIn=IdIn[(numIdentities+1):(numIdentities+296)] )
    
  if(n==1){
    idToTraitDf <- matrix(nrow=0,ncol=ncol(x2))
    idToTraitDf <- rbind(idToTraitDf, x2)
  }else{
    idToTraitDf <- rbind(idToTraitDf, x2)
  }
     
  x3 <- cbind(subID = i, idNum = numIdentities, idEdgT = idEdgT, idDensity = density, idTrans = idTrans, idStrengHom = idStrengHom, idPosHom = idPosHom, idStigHom = idStigHom, idSizeSHom = idSzSHom, idSizeUHom = idSzUHom, idSizeDHom = idSzDHom, idInclusHom = idInclusHom, idDifferHom = idDifferHom, traitCommGlob = traitCommGlob,idCommGlob=idCommGlob,
              idCommRaceM=idCommRaceM, idDistGlob=idDistGlob, idDistRaceM=idDistRaceM, idDistGlobW=idDistGlobW, idDistRaceMW=idDistRaceMW, traitDistRaceP=traitDistRaceP, traitDistRaceN=traitDistRaceN,
              globEff = globEff)
      
  if(n==1){
    globalIDDf <- matrix(nrow=0,ncol=ncol(x3))
    globalIDDf <- rbind(globalIDDf, x3)
  }else{
    globalIDDf <- rbind(globalIDDf, x3)
  }
}
idDf <- as.data.frame(idDf)
idToTraitDf <- as.data.frame(idToTraitDf)
globalIDDf <- as.data.frame(globalIDDf)

idDf[,3:ncol(idDf)]<-apply(idDf[,3:ncol(idDf)], 2, as.numeric)
idToTraitDf[,3:ncol(idToTraitDf)]<-apply(idToTraitDf[,3:ncol(idToTraitDf)], 2, as.numeric)
globalIDDf[,2:ncol(globalIDDf)]<-apply(globalIDDf[,2:ncol(globalIDDf)], 2, as.numeric)
```

```{r}
# get list of all adjacency matrices
adjList<-lapply(uIds, function(x) get(paste0("subItoTonlyFMat.",x)))
numId <- lapply(adjList, function(x) which(colnames(x)=="Accurate")-1)

# subject tendency to nominate traits across all identities
adjListI<-lapply(1:length(adjList),function(x) adjList[[x]][1:numId[[x]],])

sumNomsAcrossIdentities<-vector(length=length(adjListI))
for(n in 1:length(adjListI)){
  if(numId[n]==1){
    sumNomsAcrossIdentities[n] <- sum(adjListI[[n]])
  }else{
    sumNomsAcrossIdentities[n] <- mean(rowSums(adjListI[[n]]))
  }
}

#sumNomsAcrossIdentities <- lapply(adjListI, function(x) ifelse(class(x)=="numeric", sum(x), mean(rowSums(x)) )  )

#adjListT<-lapply(adjList, function(x) x[1:numIdentities,(numIdentities+1) : (numIdentities+296)])
#sumsAcrossTraits <- lapply(adjListT, function(x) (colSums(x)))
#sumNomsAcrossTraits <- colMeans(do.call(rbind, sumsAcrossTraits))

sumNomsAcrossTraits <- matrix(nrow=296,ncol=length(uIds))
for(n in 1:length(uIds)){
  numId<-(which(colnames(adjList[[n]])=="Accurate")-1)
  sumNomsAcrossTraits[,n] <- colSums(adjList[[n]][,(numId+1):(numId+296)])
}
sumNomsAcrossTraits<-rowMeans(sumNomsAcrossTraits)

tendSubdDf <- as.data.frame(
  cbind(subID = uIds, 
        subTend = sumNomsAcrossIdentities
)
)

tendTraitDf <- as.data.frame(
  cbind(traits = c(posTraits$trait, negTraits$trait), 
        traitTend = sumNomsAcrossTraits
)
)
```


```{r}
# traits that are one order distance from identity
traitIdDf1st <- data.frame()
for(i in uIds){
  for(j in 1:length(idNames)){
    subDf <- rawFirst[rawFirst$id==i,]
    
    # traits connected
    curGraph <- get(paste0("subTonlyFGraph.",i))
    traits1st <- ego(curGraph, order = 1, nodes = j, mindist = 1)
    namesTraits <- names(unlist(traits1st))

    traitIdDf1st <- rbind(traitIdDf1st, data.frame(subID = rep(i,length(namesTraits)), id = rep(idNames[j],length(namesTraits)), traits = namesTraits))
  }
}
```

# dataframe of identity ratings

```{r}
idSubs <- grep("I_I1",colnames(rawSec)):grep("D_I8",colnames(rawSec),)
idValue <- rawSec[idSubs]
idValue$id <- rawSec$id

longId <- data.frame()
wideId <- data.frame(matrix(ncol=0,nrow=nrow(rawSec)))

#rename(rawSec, ends_with("_1"))

labels <- c("I_","P_","St_","Sz_","Sz_","A_","D_")

for(k in 1:length(labels)){
  
  if(k==1){
    kc="I_"
    kn="streng"
    sf=""
    ke=""
  }else if(k==2){
    kc="P_"
    kn="pos"
    sf=""
    ke=""
  }else if(k==3){
    kc="St_"
    kn="stig"
    sf=""
    ke=""
  }else if(k==4){
    kc="Sz_"
    kn="sizeS"
    ke="_1"
    sf=seq(from=1,to=15,by=2)
  }else if(k==5){
    kc="Sz_"
    kn="sizeU"
    sf=seq(from=2,to=16,by=2)
    ke="13"
  }else if(k==6){
    kc="A_"
    kn="inclus"
    ke=""
  }else if(k==7){
    kc="D_"
    kn="differ"
    ke=""
  }
  
  kcols <- grep(paste0("^",kc),colnames(rawSec))
  if(length(kcols)>8){
    kcols <- kcols[sf]
  }
  # if(sf!=""){
  #   grep(kco
  # }
  if(k==4 | k==5){
    df<-idValue %>% 
    select(intersect(starts_with(kc) , ends_with(ke)), id) %>%
    pivot_longer(cols=c(starts_with(kc)), names_to = c("idcode"), values_to = kn, names_repair = "unique", names_prefix = kc)
  }else{
    df<-idValue %>% 
    select(starts_with(kc), id) %>%
    pivot_longer(cols=c(starts_with(kc)), names_to = c("idcode"), values_to = kn, names_repair = "unique", names_prefix = kc)
  }

  
  
  
  colnames(df)[1:2] <- c("subID","idcode")
  
  if(any(k==c(4,5))){
    df$idcode <- sub("_[^_]+$", "", df$idcode)
  }
  
  assign(paste0(kc,"long"),df)
  
  
  if(k==4 | k==5){
    wideId<-cbind(wideId,select(idValue, intersect(starts_with(kc) , ends_with(ke) ))) 
  }else if(k==1){
    wideId<-cbind(wideId, select(idValue, id, starts_with(kc)))
  }else{
    wideId<-cbind(wideId, select(idValue, starts_with(kc)))
  }
  
  if(k==2){
    idLong<-merge(I_long, P_long, by = c("subID","idcode"))
  }else if(k>2){
    idLong <- merge(idLong, df, by = c("subID","idcode"))
  }
  
  if(k>2){
    summarized <- Rmisc::summarySE(data=idLong, measurevar = "streng", groupvars = c("subID","idcode"))
    if(any(summarized$N>1)){
      break
    }
  }
  
  
  # print(dim(df))
  # print(dim(idLong))
  
}

# # merge
# idLong <- merge(P_long, M_long, by = c("subID","id"))
# idLong <- merge(idLong, U_long, by = c("subID","id"))
# idLong <- merge(idLong, I_long, by = c("subID","id"))

idLong$sizeD <- idLong$sizeS - idLong$sizeU
idLong$OD <- idLong$inclus - idLong$differ

idLong$idcode <- gsub("I","",idLong$idcode)

# merge with first half identity centrality measures
idLong <- merge(idLong, idDf, by = c("subID","idcode"))

wideId <-wideId
wideId <- wideId %>% rename(subID = id) %>% relocate(subID, .before=I_I1)
```


```{r}
traitLong<-pivot_longer(rawSec, cols=Accurate:Worrier, names_to = c("traits"), values_to = "selfResp", names_repair = "unique")
names(traitLong)[colnames(traitLong)=="id"] <- "subID"
traitLong<-traitLong[c("subID","traits","selfResp")]

# convert . to - to match original trait words that are hyphenated
traitLong$traits <- gsub("\\.","-", traitLong$traits)
```

```{r}
fullLong <- merge(traitLong, traitIdDf1st, by = c("subID","traits"))
fullLong<-fullLong[order(fullLong$subID, fullLong$id),]
fullLong <- merge(fullLong, idLong, by = c("subID","id"))
```

# Categorical and Qualitative Identity Kavels

```{r}
category <- function(fact){
  recode_factor(fact, "1" = "race", 
                                "2" = "gender",
                                "3" = "sex",
                                "4" = "pol",
                                "5" = "ses",
                                "6" = "rel",
                                "7" = "occ",
                                "8" = "hobb",
                                "9" = "fam",
                                "10" = "friend",
                                "11" = "other")
}
category(rawFirst$I2_Cat)

rawFirst <- rawFirst %>%
  mutate(I1_Cat = category(as_factor(I1_Cat)),
                         I2_Cat = category(as_factor(I2_Cat)),
                         I3_Cat = category(as_factor(I3_Cat)),
                         I4_Cat = category(as_factor(I4_Cat)),
                         I5_Cat = category(as_factor(I5_Cat)),
                         I6_Cat = category(as_factor(I6_Cat)),
                         I7_Cat = category(as_factor(I7_Cat)),
                         I8_Cat = category(as_factor(I8_Cat))
                                          )

idcdf <- rawFirst %>% select(id, ends_with("_Cat")) %>% pivot_longer(!id, names_to="idcode",values_to="idc")
idcdf <- rename(idcdf, subID = id)
idcdf$idcode <-  str_replace(idcdf$idcode, "_Cat","")
idcdf$idcode <-  str_replace(idcdf$idcode, "I","")
idcdf <- idcdf[!is.na(idcdf$idc),]

idqdf <- idMat %>% pivot_longer(!subID, names_to="idcode",values_to="idq")
idqdf$idcode <-  str_replace(idqdf$idcode, "I","")
idqdf <- idqdf[!is.na(idqdf$idq),]

# merge
qcidlong <- merge(idcdf, idqdf, by = c("subID","idcode"))
```


```{r}
fullLong <- merge(fullLong, qcidlong, by = c("subID","idcode"))
```

# Ind Diff Cleaning

```{r}

indDiffT1 <- rawFirst %>% select(id,RSE1:MGIS_14,Educ,Status)
indDiffT2 <- rawSec %>% select(id,RSE1:SCS_10,Condition,identity)
indDiffT1<-rename(indDiffT1, subID=id)
indDiffT2<-rename(indDiffT2, subID=id)
indDiffT2$check4 <- NULL
```

## Need for Cognition

```{r}
NFCrevcols = c("NFC.6_3", "NFC.6_4")
indDiffT2[ ,NFCrevcols] = 8 - indDiffT2[ ,NFCrevcols]
ind1 <- grep("NFC.6_1", colnames(indDiffT2))
ind1<-min(ind1)
ind2<- grep("NFC.6_6", colnames(indDiffT2))
ind2<-max(ind2)
# Compute scores for Need for Cog
indDiffT2$NFC = rowMeans(indDiffT2[, ind1:ind2], na.rm = TRUE)

psych::alpha(indDiffT2[ind1:ind2])
```

## Multicomponent Group Identification Scale

# Time 1

```{r}
# Solidarity items
MGIS_Solidcols = paste0("MGIS_",c(1,2,3))
indDiffT1$MGIS_Solid.T1 = rowMeans(indDiffT1[, MGIS_Solidcols], na.rm = TRUE)
psych::alpha(indDiffT1[MGIS_Solidcols])$total
# Solidarity items
MGIS_Satiscols = paste0("MGIS_",c(4,5,6,7))
indDiffT1$MGIS_Satis.T1 = rowMeans(indDiffT1[, MGIS_Satiscols], na.rm = TRUE)
psych::alpha(indDiffT1[MGIS_Satiscols])$total
# Solidarity items
MGIS_Centcols = paste0("MGIS_",c(8,9,10))
indDiffT1$MGIS_Cent.T1 = rowMeans(indDiffT1[, MGIS_Centcols], na.rm = TRUE)
psych::alpha(indDiffT1[MGIS_Centcols])$total
# Self-Investment items
MGIS_SIcols = paste0("MGIS_",1:10)
indDiffT1$MGIS_SI.T1 = rowMeans(indDiffT1[, MGIS_SIcols], na.rm = TRUE)
psych::alpha(indDiffT1[MGIS_SIcols])$total
# Solidarity items
MGIS_ISeStercols = paste0("MGIS_",c(11,12))
indDiffT1$MGIS_ISeSte.T1 = rowMeans(indDiffT1[, MGIS_ISeStercols], na.rm = TRUE)
psych::alpha(indDiffT1[MGIS_ISeStercols])$total
# Solidarity items
MGIS_GSeStercols = paste0("MGIS_",c(13,14))
indDiffT1$MGIS_GSeSte.T1 = rowMeans(indDiffT1[, MGIS_GSeStercols], na.rm = TRUE)
psych::alpha(indDiffT1[MGIS_GSeStercols])$total
# Self-Definition items
MGIS_SDcols = paste0("MGIS_",11:14)
indDiffT1$MGIS_SD.T1 = rowMeans(indDiffT1[, MGIS_SDcols], na.rm = TRUE)
psych::alpha(indDiffT1[MGIS_SDcols])$total
# MGIS
MGIS_cols = paste0("MGIS_",1:14)
indDiffT1$MGIS.T1 = rowMeans(indDiffT1[, MGIS_cols], na.rm = TRUE)
psych::alpha(indDiffT1[MGIS_cols])$total
```


# Time 2

```{r}
# Solidarity items
MGIS_Solidcols = paste0("MGIS_",c(1,2,3))
indDiffT2$MGIS_Solid.T2 = rowMeans(indDiffT2[, MGIS_Solidcols], na.rm = TRUE)
psych::alpha(indDiffT2[MGIS_Solidcols])$total
# Solidarity items
MGIS_Satiscols = paste0("MGIS_",c(4,5,6,7))
indDiffT2$MGIS_Satis.T2 = rowMeans(indDiffT2[, MGIS_Satiscols], na.rm = TRUE)
psych::alpha(indDiffT2[MGIS_Satiscols])$total
# Solidarity items
MGIS_Centcols = paste0("MGIS_",c(8,9,10))
indDiffT2$MGIS_Cent.T2 = rowMeans(indDiffT2[, MGIS_Centcols], na.rm = TRUE)
psych::alpha(indDiffT2[MGIS_Centcols])$total
# Self-Investment items
MGIS_SIcols = paste0("MGIS_",1:10)
indDiffT2$MGIS_SI.T2 = rowMeans(indDiffT2[, MGIS_SIcols], na.rm = TRUE)
psych::alpha(indDiffT2[MGIS_SIcols])$total
# Solidarity items
MGIS_ISeStercols = paste0("MGIS_",c(11,12))
indDiffT2$MGIS_ISeSte.T2 = rowMeans(indDiffT2[, MGIS_ISeStercols], na.rm = TRUE)
psych::alpha(indDiffT2[MGIS_ISeStercols])$total
# Solidarity items
MGIS_GSeStercols = paste0("MGIS_",c(13,14))
indDiffT2$MGIS_GSeSte.T2 = rowMeans(indDiffT2[, MGIS_GSeStercols], na.rm = TRUE)
psych::alpha(indDiffT2[MGIS_GSeStercols])$total
# Self-Definition items
MGIS_SDcols = paste0("MGIS_",11:14)
indDiffT2$MGIS_SD.T2 = rowMeans(indDiffT2[, MGIS_SDcols], na.rm = TRUE)
psych::alpha(indDiffT2[MGIS_SDcols])$total
# MGIS
MGIS_cols = paste0("MGIS_",1:14)
indDiffT2$MGIS.T2 = rowMeans(indDiffT2[, MGIS_cols], na.rm = TRUE)
psych::alpha(indDiffT2[MGIS_cols])$total
```

## Stigma Consciousness Scale

# Time 1

```{r}
# Reverse code Stigma Consciousness items
SCSrevcols = paste0("SCS_",c(1,2,4,5,6,7,9))
indDiffT1[ ,SCSrevcols] = 8 - indDiffT1[ ,SCSrevcols]
ind1 <- grep("^SCS_1$", colnames(indDiffT1))
ind1<-min(ind1)
ind2<- grep("^SCS_10$", colnames(indDiffT1))
ind2<-max(ind2)
# Compute scores for Stigma Consciousness
indDiffT1$SCS.T1 = rowMeans(indDiffT1[, ind1:ind2], na.rm = TRUE)
psych::alpha(indDiffT1[ind1:ind2])
```


# Time 2

```{r}
# Reverse code Stigma Consciousness items
SCSrevcols = paste0("SCS_",c(1,2,4,5,6,7,9))
indDiffT2[ ,SCSrevcols] = 8 - indDiffT2[ ,SCSrevcols]
ind1 <- grep("^SCS_1$", colnames(indDiffT2))
ind1<-min(ind1)
ind2<- grep("^SCS_10$", colnames(indDiffT2))
ind2<-max(ind2)
# Compute scores for Stigma Consciousness
indDiffT2$SCS.T2 = rowMeans(indDiffT2[, ind1:ind2], na.rm = TRUE)
psych::alpha(indDiffT2[ind1:ind2])
```

## Self-Esteem

# Time 1

```{r}
# Reverse code Rosenberg Self-Esteem items
SErevcols = c("RSE2", "RSE5", "RSE6", "RSE8", "RSE9")
indDiffT1[ ,SErevcols] = 5 - indDiffT1[ ,SErevcols]
ind1 <- grep("^RSE1$", colnames(indDiffT1))
ind1<-min(ind1)
ind2<- grep("^RSE10$", colnames(indDiffT1))
ind2<-max(ind2)
# Compute scores for Rosenberg Self-Esteem
indDiffT1$SE.T1 = rowMeans(indDiffT1[, ind1:ind2], na.rm = TRUE)
indDiffT1$SE.T1 <- 5 - indDiffT1$SE.T1
psych::alpha(indDiffT1[ind1:ind2])
```


# Time 2

```{r}
# Reverse code Rosenberg Self-Esteem items
SErevcols = c("RSE2", "RSE5", "RSE6", "RSE8", "RSE9")
indDiffT2[ ,SErevcols] = 5 - indDiffT2[ ,SErevcols]
ind1 <- grep("^RSE1$", colnames(indDiffT2))
ind1<-min(ind1)
ind2<- grep("^RSE10$", colnames(indDiffT2))
ind2<-max(ind2)
# Compute scores for Rosenberg Self-Esteem
indDiffT2$SE.T2 = rowMeans(indDiffT2[, ind1:ind2], na.rm = TRUE)
indDiffT2$SE.T2 <- 5 - indDiffT2$SE.T2
psych::alpha(indDiffT2[ind1:ind2])
```

# PANAS

# Time 1

```{r}
posinds<-paste0("PANAS_",c(1, 3, 5, 9, 10, 12, 14, 16, 17, 19))
neginds<-paste0("PANAS_",c(2, 4, 6, 7, 8, 11, 13, 15, 18, 20))
indDiffT1$PANAS_Neg.T1 = rowMeans(indDiffT1[, neginds], na.rm = TRUE)
indDiffT1$PANAS_Pos.T1 = rowMeans(indDiffT1[, posinds], na.rm = TRUE)

psych::alpha(indDiffT1[posinds])

psych::alpha(indDiffT1[neginds])
```

## Time 2

```{r}
posinds<-paste0("PANAS_",c(1, 3, 5, 9, 10, 12, 14, 16, 17, 19))
neginds<-paste0("PANAS_",c(2, 4, 6, 7, 8, 11, 13, 15, 18, 20))
indDiffT2$PANAS_Neg.T2 = rowMeans(indDiffT2[, neginds], na.rm = TRUE)
indDiffT2$PANAS_Pos.T2 = rowMeans(indDiffT2[, posinds], na.rm = TRUE)

psych::alpha(indDiffT2[posinds])

psych::alpha(indDiffT2[neginds])
```


## Collective Self-Esteem

```{r}
attach(indDiffT2)
# Reverse code Collective Self-Esteem items (2, 4, 5, 7, 10 ,12, 13, 15)
CSErevcols = c("CSE2", "CSE4", "CSE5", "CSE7", "CSE10", "CSE12", "CSE13", "CSE15")
indDiffT2[ ,CSErevcols] = 8 - indDiffT2[ ,CSErevcols]
# Compute score for Membership Self-Esteem
MemSEcols = c("CSE1", "CSE5", "CSE9", "CSE10")
indDiffT2$MemSE = rowMeans(indDiffT2[, MemSEcols], na.rm = TRUE)
psych::alpha(indDiffT2[,MemSEcols])
# Compute score for Private Collective Self-Esteem
PrivCSEcols = c("CSE2", "CSE6", "CSE10", "CSE14")
indDiffT2$PrivCSE = rowMeans(indDiffT2[, PrivCSEcols], na.rm = TRUE)
psych::alpha(indDiffT2[,PrivCSEcols])
# Compute score for Public Collective Self-Esteem
PubCSEcols = c("CSE3", "CSE7", "CSE11", "CSE15")
indDiffT2$PubCSE = rowMeans(indDiffT2[, PubCSEcols], na.rm = TRUE)
psych::alpha(indDiffT2[,PubCSEcols])
# Compute score for Importance to Identity
IdImpcols = c("CSE4", "CSE8", "CSE12", "CSE16")
indDiffT2$IdImp = rowMeans(indDiffT2[, IdImpcols], na.rm = TRUE)
psych::alpha(indDiffT2[,IdImpcols])
detach(indDiffT2)
```

## Dialectical Self-Views

```{r}
# Reverse code Need for Cog items
#DSrevcols = c("DS_2", "DS_5", "DS_6", "DS_12", "DS_13", "DS_15", "DS_16")
#DSrevcols = c("DS_5", "DS_7", "DS_8", "DS_13", "DS_15", "DS_16")
#DSrevcols = c("DS_2", "DS_6", "DS_10", "DS_12", "DS_17")
# reverse score 1, 5, 6, 7, 9, 14

columnNames <- colnames(indDiffT2[grep("^DS",colnames(indDiffT2))])
DSrevcols <- columnNames[c(1,5,6,7,9,14)]
#DSrevcols = c("DS_1", "DS_7", "DS_8", "DS_9", "DS_11","DS_17")
indDiffT2[ ,DSrevcols] = 8 - indDiffT2[ ,DSrevcols]
ind1 <- grep("DS_1", colnames(indDiffT2))
ind1<-min(ind1)
ind2<- grep("DS_14", colnames(indDiffT2))
ind2<-max(ind2)
# Compute scores for Need for Cog
indDiffT2$DS = rowMeans(indDiffT2[, ind1:ind2], na.rm = TRUE)

psych::alpha(indDiffT2[ind1:ind2])
```

## Self-Concept Clarity

```{r}
# Reverse code Self-Concept Clarity Scale items
SCC_revcols = c("SCC1", "SCC2", "SCC3", "SCC4", "SCC5", "SCC7", 
                 "SCC8", "SCC9", "SCC10", "SCC12")
indDiffT2[ ,SCC_revcols] = 6 - indDiffT2[ ,SCC_revcols]
ind1 <- grep("SCC1", colnames(indDiffT2))
ind1<-min(ind1)
ind2<- grep("SCC12", colnames(indDiffT2))
ind2<-max(ind2)
# Compute score for Self-Concept Clarity Scale items
indDiffT2$SCC = rowMeans(indDiffT2[,ind1:ind2], na.rm = TRUE)

psych::alpha(indDiffT2[ind1:ind2])
```

## Satisfaction with Life

```{r}
ind1 <- grep("SWLS_1", colnames(indDiffT2))
ind1<-min(ind1)
ind2<- grep("SWLS_5", colnames(indDiffT2))
ind2<-max(ind2)
# Compute score for Self-Concept Clarity Scale items
indDiffT2$SWLS = rowMeans(indDiffT2[,ind1:ind2], na.rm = TRUE)

psych::alpha(indDiffT2[ind1:ind2])
```

## CESD

```{r}
# Reverse code Self-Concept Clarity Scale items
CESD_revcols = c("CESD4", "CESD8", "CESD12", "CESD16")
indDiffT2[ ,CESD_revcols] = 5 - indDiffT2[ ,CESD_revcols]
ind1 <- grep("CESD", colnames(indDiffT2))
ind1<-min(ind1)
ind2<- grep("CESD", colnames(indDiffT2))
ind2<-max(ind2)
# Compute score for Self-Concept Clarity Scale items
indDiffT2$CESD = rowMeans(indDiffT2[,ind1:ind2], na.rm = TRUE)
psych::alpha(indDiffT2[ind1:ind2])
```

## Singelis Self-Construal

```{r}
# Compute score for Independent
Indcols = c("Sing1", "Sing2", "Sing5", "Sing7", "Sing9", "Sing10", "Sing13", "Sing15", "Sing18", "Sing20", "Sing22", "Sing24", "Sing25", "Sing27", "Sing29")
indDiffT2$Ind = rowMeans(indDiffT2[, Indcols], na.rm = TRUE)
psych::alpha(indDiffT2[,Indcols])
# Compute score for Interdependent
Indcols = c("Sing3", "Sing4", "Sing6", "Sing8", "Sing11", "Sing12", "Sing14", "Sing16", "Sing17", "Sing19", "Sing21", "Sing23", "Sing26", "Sing28", "Sing30")
indDiffT2$Inter = rowMeans(indDiffT2[, Indcols], na.rm = TRUE)
psych::alpha(indDiffT2[,Indcols])
```

# Self-Complexity Scores

```{r}
#devtools::install_github("edinkasia/self-complexity-package")
library(selfcomplexity)
selfcomplexityDf <- traitIdDf1st %>%
  group_by(subID, id) %>%
  summarize(att = paste(traits, collapse = ','))

HScores<-calculate_H(data=as.tibble(selfcomplexityDf),att_column = "att", id_column = "subID", vector = c(posTraits$trait,negTraits$trait))

OverlapScores<-calculate_overlap(data=as.tibble(selfcomplexityDf), att_column="att", subtype_column = "id", id_column = "subID")

PhiScores<-calculate_phi(data=as.tibble(selfcomplexityDf),att_column = "att", id_column = "subID", pos_att_vector = posTraits$trait, neg_att_vector =  negTraits$trait)

SCdf <- merge(HScores, OverlapScores, by = "subID")
SCdf <- merge(SCdf, PhiScores, by = "subID")
```


```{r}
indDiffT2shorten <- indDiffT2 %>% select(subID, Inter, Ind, CESD, SWLS, SCC, DS, IdImp, PubCSE, PrivCSE, MemSE, PANAS_Pos.T2, PANAS_Neg.T2, SE.T2, SCS.T2, intersect(starts_with("MGIS_"),ends_with(".T2")), MGIS.T2, identity, Condition)
indDiffT1shorten <- indDiffT1  %>% select(subID, Educ, Status, PANAS_Pos.T1, PANAS_Neg.T1, SE.T1, SCS.T1, intersect(starts_with("MGIS_"),ends_with(".T2")), MGIS.T1)
indDiff <- merge(indDiffT1shorten, indDiffT2shorten, by = "subID")
indDiff <- merge(indDiff, SCdf, by = "subID")
fullLong <- merge(fullLong, globalIDDf, by = "subID", all.x = T)
```

# generate dataframe for semantic distance from identity

```{r}
nrows <- sum( apply(idMat, 1, function(x) 8-sum(is.na(x))) ) * length(uIds) * 296 # number of rows based on number of dientities per p
distMatText <- matrix(nrow=nrows,ncol=4)
distMatNum <- matrix(nrow=nrows,ncol=6)
#idToSimMat <- matrix(nrow = 0, ncol = 5)

iter <- 1
for(n in 1:length(uIds)){
  i <- uIds[n]
  identities <- idMat[idMat$subID==i,2:9] %>% as_vector() %>% na.omit()
  traits <- c(posTraits$trait, negTraits$trait)
  
  if(iter == 1){
    iterator1 <- 1
    iterator2 <- (296*length(identities))
  }else{
    iterator1 <- iterator2 + 1
    iterator2 <- iterator1+((296*length(identities))-1)
  }
 
  
  evals <- rep(traitLong$selfResp[traitLong$subID==i],length(identities))
  curGraph1 <- get(paste0("subTonlyFGraph.",i))
  distMatT <- distances(curGraph1, mode = "all")[1:length(identities),(length(identities)+1) : (length(identities)+296)]
  distT <- c(t(distMatT))
  distMatO <- distances(curGraph1, mode = "out")[1:length(identities),(length(identities)+1) : (length(identities)+296)]
  distO <- c(t(distMatO))
  
  curGraph1 <- get(paste0("subTFGraph.",i))
  curGraph2 <- get(paste0("subTonlyFGraph.",i))
  simsMat1 <- similarity.dice(curGraph1)[1:length(identities),(length(identities)+1) : (length(identities)+296)]
  IT.Sim <- c(t(simsMat1))
  simsMat2 <- similarity.dice(curGraph2)[1:length(identities),(length(identities)+1) : (length(identities)+296)]
  T.Sim <- c(t(simsMat2))
  
  block1 <- cbind(rep(i, length(identities)*296), evals, distT, distO, IT.Sim, T.Sim)
  block2 <- cbind(rep(traits,length(identities)), rep(c(rep("positive",148),rep("negative",148)),length(identities)),
                  rep(identities, each=296), rep(1:length(identities), each=296))
  
  distMatText[iterator1:iterator2, 1:ncol(block2)] <- block2
  distMatNum[iterator1:iterator2, 1:ncol(block1)] <- block1
  
  iter <- iter + 1
}
orderDf <- cbind(as.data.frame(distMatText), as.data.frame(distMatNum))
orderDf[(ncol(distMatText)+1):ncol(orderDf)] <- apply(orderDf[(ncol(distMatText)+1):ncol(orderDf)], 2, as.numeric)
colnames(orderDf) <- c("traits","valence","idq","idcode","subID","selfResp","order","orderO", "IT.Sim", "T.Sim")
orderDf <- as.data.frame(orderDf)


orderDf <- orderDf[order(orderDf$subID, orderDf$order),]
orderDf <- merge(orderDf, qcidlong, by = c("subID","idcode","idq"))
orderDf <- merge(orderDf, idLong, by = c("subID","idcode"))
orderDf <- merge(orderDf, indDiff, by = "subID")
orderDf <- merge(orderDf, globalIDDf, by = c("subID"), all.x = T, all.y=T)

orderDf$order[is.infinite(orderDf$order)] <- NA
orderDf$orderO[is.infinite(orderDf$orderO)] <- NA

cur<-orderDf[, c("order","T.Sim")]
PCAall<- prcomp(na.omit(cur),
             center = TRUE,
            scale. = TRUE)
orderDf$PCAdist[!is.na(orderDf$order) & !is.na(orderDf$T.Sim)] <- PCAall$x[,1]
```

```{r}
uSub<-unique(fullLong$subID)
uId<-unique(fullLong$id)
# nrow(fullLong)
# test<-fullLong[fullLong$id %in% as.array(uId), ]
# test<-subset(fullLong, subID==uSub & id==uId)

idShort <- merge(idLong, qcidlong, by = c("subID","idcode"))
idShort <- merge(idShort, indDiff, by = c("subID"))
idShort <- merge(idShort, globalIDDf, by = c("subID"), all.x = T)
for(i in uSub){
  for(j in uId){
    idShort$sdSR[idShort$subID==i & idShort$id==j] <- sd(fullLong$selfResp[fullLong$subID==i & fullLong$id==j],na.rm=T)
  }
}
```

```{r}
fullLong <- merge(fullLong, idToTraitDf, by = c("subID","traits"))
```

```{r}
traits<-rbind(posTraits, negTraits)
traits$Idx <- 1:296
colnames(traits)[colnames(traits)=="trait"] <- "traits"
fullLong <- merge(fullLong, traits, by = "traits")
orderDf <- merge(orderDf, traits, by = c("traits","valence"))
```


```{r}
uIds <- unique(idShort$subID)
#uId <- unique(idShort$id)

#fullSimDf <- matrix(ncol=6, nrow=8*length(uIds))
fullSimDf <- data.frame()

for(i in uIds){
    #subDf <- rawFirst[rawFirst$id==i,]
    subDf <- idShort[idShort$subID==i,]
    
    idNames <- idMat[idMat$subID==i,2:9] %>% as_vector() %>% na.omit()
     numIdentities <- sum(!is.na(idMat[idMat$subID==i,2:9]))
     
     if(numIdentities==1){
       next
     }
  
    # identity to identity causing
    curGraph <- get(paste0("subIGraph.",i))
    
    # identity to all traits graph
    curGraphItoT <- get(paste0("subItoTonlyFGraph.",i))
    
    # identity to pos traits graph
    curGraphItoT.p <- get(paste0("subItoTonlyPGraph.",i))
    
    # identity to neg traits graph
    curGraphItoT.n <- get(paste0("subItoTonlyNGraph.",i))
    
    sim=similarity.dice(curGraph)
    simVect=sim[lower.tri(sim)==T]
    # if(length(simVect)<28){
    #   break
    # }
    
    # Dice Similarity in All Shared Traits
    simIT=similarity.dice(curGraphItoT)
    simIT=simIT[1:numIdentities,1:numIdentities]
    simVectIT=simIT[lower.tri(simIT)==T]
    # if(length(simVectIT)<28){
    #   break
    # }
    
    # Dice SimilarIy in All Shared TraIT.ps
    simIT.p=similarity.dice(curGraphItoT.p)
    simIT.p=simIT.p[1:numIdentities,1:numIdentities]
    simVectIT.p=simIT.p[lower.tri(simIT.p)==T]
    # if(length(simVectIT.p)<28){
    #   break
    # }
    
    # Dice Similarity in Neg Shared Traits
    simIT.n=similarity.dice(curGraphItoT.n)
    simIT.n=simIT.n[1:numIdentities,1:numIdentities]
    simVectIT.n=sim[lower.tri(simIT.n)==T]
    # if(length(simVectIT.n)<28){
    #   break
    # }
    
    # distance of positivity
    posVect <- as.vector(dist(idShort$pos[idShort$subID==i]))
    # if(length(posVect)<28){
    #   break
    # }
    # distance of identification
    strengVect <- as.vector(dist(idShort$streng[idShort$subID==i]))
    # if(length(strengVect)<28){
    #   break
    # }
    # distance of stigma
    stigVect <- as.vector(dist(idShort$stig[idShort$subID==i]))
    # if(length(stigVect)<28){
    #   break
    # }
    # distance of size school
    sizeSVector <- as.vector(dist(idShort$sizeS[idShort$subID==i]))
    # if(length(sizeSVector)<28){
    #   break
    # }
    # distance of size school
    sizeUVector <- as.vector(dist(idShort$sizeU[idShort$subID==i]))
    # if(length(sizeUVector)<28){
    #   break
    # }
    inclusVector <- as.vector(dist(idShort$inclus[idShort$subID==i]))
    # if(length(inclusVector)<28){
    #   break
    # }
    differVector <- as.vector(dist(idShort$differ[idShort$subID==i]))
    # if(length(differVector)<28){
    #   break
    # }

    
    curSimDf <- cbind(subID = rep(i,length(simVect)), pair = 1:length(simVect), idSim = simVect, idtSim = simVectIT, idtpSim = simVectIT.p, idtnSim = simVectIT.n, posDist = posVect, strengDist = strengVect, stigDist = stigVect, sizeSDist = sizeSVector, sizeUDist = sizeUVector, inclusDist = inclusVector, differDist = differVector)
    
    fullSimDf <- rbind(fullSimDf, curSimDf)
    
}
fullSimDf <- merge(fullSimDf, indDiff, by="subID")
```


```{r}
netWide <- pivot_wider(idShort[c("subID","id","I2Ideg","cI2Tdeg","pI2Tdeg","nI2Tdeg","idCommNod","traitCommNod")], values_from = c(I2Ideg, cI2Tdeg, pI2Tdeg, nI2Tdeg, idCommNod, traitCommNod), names_from = id)
wideId <- merge(wideId, netWide, by = "subID")
```

```{r}
veryLong <- merge(traitLong, idLong, by = "subID")
traits$Idx <- 1:296
veryLong <- merge(veryLong, traits, by.x = "traits", by = "traits")
veryLong <- veryLong[order(veryLong$subID, veryLong$Idx),]
veryLong$connect <- 0
for(i in unique(veryLong$subID)){
  idNames <- idMat[idMat$subID==i,2:9] %>% as_vector() %>% na.omit()
  numIdentities <- sum(!is.na(idMat[idMat$subID==i,2:9]))
  
  for(j in 1:numIdentities){
    curMat <- get(paste0("subTFMat.",i))
    veryLong$connect[veryLong$subID==i & veryLong$idcode==j] <- as.numeric(curMat[j,(numIdentities+1):(numIdentities+296)])
    #which(veryLong$traits[veryLong$subID==i & veryLong$id==j]==traitIdDf1st$traits[veryLong$subID==i & veryLong$id==j])
  }
}



fullLong2 <- subset(veryLong, connect == 1)
veryLong <- merge(veryLong, qcidlong, by = c("subID","idcode"))
veryLong <- merge(veryLong, indDiff, by = "subID", all.x=T)
veryLong <- merge(veryLong, globalIDDf, by = c("subID"), all.x = T)
veryLong <- merge(veryLong, idToTraitDf, by = c("subID","traits"))
```

```{r}
RaceLong <- subset(veryLong, idcode==1)
RaceLong$connectn <- as.numeric(RaceLong$connect)-1
summarized <- Rmisc::summarySE(data=RaceLong, measurevar = "connect", groupvars = c("subID"))
summarized <- Rmisc::summarySE(data=traitLong, measurevar = "selfResp", groupvars = c("subID"))
summarized <- Rmisc::summarySE(data=idLong, measurevar = "streng", groupvars = c("subID","idcode"))
```

```{r}
#troublesubs <- fullLong1[fullLong1$subID %in% summarized$subID[which(summarized$N>296)]]
```

```{r}
veryLong <- merge(veryLong, tendSubdDf, by = "subID", all.x=T)
orderDf <- merge(orderDf, tendSubdDf, by = "subID", all.x=T)
idShort <- merge(idShort, tendSubdDf, by = "subID", all.x=T)
indDiff <- merge(indDiff, tendSubdDf, by = "subID", all.x=T)
fullSimDf <- merge(fullSimDf, tendSubdDf, by = "subID", all.x=T)


veryLong <- merge(veryLong, tendTraitDf, by = "traits", all.x=T)
orderDf <- merge(orderDf, tendTraitDf, by = "traits", all.x=T)
```

```{r}
# 
# for(i in 1:nrow(veryLong)){
#   if(veryLong$connect[i]==1 & veryLong$idcode[i]==1){
#     veryLong$traitspillW[i] <- 0
#     veryLong$traitspill[i] <- 0
#   }else if(veryLong$connect[i]==1 & veryLong$idcode[i]!=1){
#     if(is.na(veryLong$idDistRaceN[i])){
#       veryLong$traitspill[i] <- 1
#     }else{
#       veryLong$traitspill[i] <- 2
#     }
#   }else if(veryLong$connect[i]==0){
#     veryLong$traitspill[i] <- 3
#   }
# }
```


```{r}
#write.csv(fullLong, "~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Output/id2traitDf.csv", row.names = F)
write.csv(demos, "~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Output/demos.csv", row.names = F)
write.csv(veryLong, "~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Output/id2traitDf.csv", row.names = F)
write.csv(orderDf, "~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Output/orderDf.csv", row.names = F)
write.csv(idShort, "~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Output/id2traitShort.csv", row.names = F)
write.csv(indDiff, "~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Output/indDiff.csv", row.names = F)
write.csv(fullSimDf, "~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Output/identitySimDf.csv", row.names = F)
write.csv(wideId, "~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Output/idWide.csv", row.names = F)
save.image("~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Output/id2traitsworkspace.RData")
```












