---
title: "R Notebook"
output: html_notebook
---

```{r}
library(igraph)
library(tidyverse)
library(careless)
```

```{r}
library(devtools)
source_url("https://raw.githubusercontent.com/JacobElder/MiscellaneousR/master/assortativityNA.R")
```

```{r}
rawFirst <- read.csv("~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Input/idFeedRaw1.csv", header = T)
rawFirst <- rawFirst[!as.numeric(duplicated(rawFirst$id)),]
rawSec <- read.csv("~/Google Drive/Volumes/Research Project/Identity Feedback/Study 1/Data/Input/idFeedRaw2.csv", header = T)
rawSec <- rawSec[!as.numeric(duplicated(rawSec$id)),]
tAdjMatP <- read.csv("~/Google Drive/Volumes/Research Project/Trait Network_Behaviral/generating network/output/adjacencyMatrix_p.csv")

tAdjMatN <- read.csv("~/Google Drive/Volumes/Research Project/Trait Network_Behaviral/generating network/output/adjacencyMatrix_n.csv")

posTraits <- read.csv("~/Google Drive/Volumes/Research Project/Trait Network_Behaviral/generating network/output/allPosCents.csv")

negTraits <- read.csv("~/Google Drive/Volumes/Research Project/Trait Network_Behaviral/generating network/output/allNegCents.csv")
```

```{r}
setwd("~/Google Drive/Volumes/")
posDf <- read.csv("./Research Project/Trait Network_Behaviral/generating network/output/adjacencyMatrix_p.csv")
posMat <- as.matrix(posDf)
posGraph <- graph.adjacency(posMat)
negDf <- read.csv("./Research Project/Trait Network_Behaviral/generating network/output/adjacencyMatrix_n.csv")
negMat <- as.matrix(negDf)
negGraph <- graph.adjacency(negMat)
```

```{r}
is.emptyString <- function(input){
  if(input==''){
    output <- TRUE
  }else{
    output <- FALSE
  }
  return(output)
}
rawFirst$identity[which(rawFirst$identity!="Asian" & rawFirst$identity!="Latino")]
rawFirst <- subset(rawFirst, rawFirst$identity=="Asian" | rawFirst$identity=="Latino")

rawidSubs <- grep("Identity.Nominations_1",colnames(rawFirst)):grep("Identity.Nominations_41",colnames(rawFirst))
emptyRows<-apply(rawFirst[rawidSubs], c(1,2), is.emptyString)
rawFirst<-rawFirst[!apply(emptyRows, 1, all),]
missRows <- rowSums(apply(select(rawSec, Accurate:Worrier), c(1,2), is.na))
badRows <- missRows > 30
rawSec <- rawSec[!badRows,]

rawFirst <- rawFirst[rawFirst$id!=47001,]
rawSec <- rawSec[rawSec$id!=47001,]

rawSec$remove <- ifelse(rawSec$Serious1 < 5 | rawSec$Serious2 < 5 | rawSec$Usable == 2 | rawSec$Off7 == 3, 1, 0)
rawSec <- rawSec[rawSec$remove!=1,]
```

# Careless responding

```{r}
# idInds <- grep("I_Race",colnames(rawSec)):grep("U_Pol",colnames(rawSec))
# trInds <- grep("Accurate",colnames(rawSec)):grep("Worrier",colnames(rawSec))
# careless_long <- longstring(rawSec[idInds])
# propIdentical1 <- careless_long/length(idInds)
# identicalID <- propIdentical1>.30
# 
# careless_long <- longstring(rawSec[trInds])
# propIdentical2 <- careless_long/length(trInds)
# identicalTR <- propIdentical2>.04
# 
# careless_irv <- irv(rawSec[idInds], split = TRUE, num.split = 3)
# carelessID <- careless_irv$irvTotal > mean(careless_irv$irvTotal)+sd(careless_irv$irvTotal)*1
# 
# careless_irv <- irv(rawSec[trInds], split = TRUE, num.split = 10)
# carelessTR <- careless_irv$irvTotal > mean(careless_irv$irvTotal)+sd(careless_irv$irvTotal)*1
# 
# synonym <- psychsyn(rawSec[trInds], critval = .60) < mean(abs(psychant(rawSec[trInds], critval = .60)),na.rm=T) - sd(psychant(rawSec[trInds], critval = .60),na.rm=T)
# 
# antonym <- abs(psychant(rawSec[trInds], critval = .30)) < mean(abs(psychant(rawSec[trInds], critval = .60)),na.rm=T) - sd(abs(psychant(rawSec[trInds], critval = .60)),na.rm=T)
# 
# carelessDf <- data.frame(identicalID, identicalTR, carelessID, carelessTR, synonym, antonym)
# rowSums(carelessDf)
# 
# rawSec <- rawSec[rowSums(carelessDf)<2,]
```

```{r}
demos <-rawFirst %>% select(id, Age:Educ)
```

```{r}
idMat <- matrix(NA,ncol=9,nrow=nrow(rawFirst))
for(n in 1:nrow(rawFirst) ){
  identities <- rawFirst %>% 
    select(Identity.Nominations_1:Identity.Nominations_41) %>%
    slice(n) %>%
    as_vector()
  
  idIndices <- identities %>%
    map(is.emptyString) %>%
    unlist()
  
  identities[idIndices] <- NA
  
  idMat[n,] <- c(rawFirst$id[n], identities)
  
  
    
}
```

# Generate identity networks

```{r}
uIds <- unique(rawFirst$id)
# column names
idSubs <- rawFirst %>%
  select(contains("_Relations"))
for(n in 1:nrow(rawFirst)){
  i <- rawFirst$id[n]
  
  idNames <- idMat[n,2:9]
  numIdentities <- sum(!is.na(idMat[n,2:9]))
  
  # subset subject row
  subDf <- rawFirst[rawFirst$id==i,]
  # generate empty matrix
  subMat <- matrix(data = 0, nrow = numIdentities, ncol = numIdentities)
  for(c in 1:numIdentities){
    # subset identity "c"
    j <- idSubs[c]
    # split words by comma
    selectWord <-strsplit(as.character(idSubs[,c][[1]]),",") 
    # which column index are select identities
    ######rowSub <-which(idNames %in% selectWord[[1]])
    # populate 1s for select identities in row
    subMat[c,as.numeric(unlist(selectWord))] <- 1
  }
  rownames(subMat) <- idNames
  colnames(subMat) <- idNames

    # convert to graph
  subGraph <- graph.adjacency(subMat)
  # label
  assign(paste0("subIMat.",i),subMat)
  assign(paste0("subIGraph.",i),subGraph)
}

```

#### STOPPED HERE ON 7-14-2022

```{r}
idSubs <- grep("Race_PosTraits",colnames(rawFirst)):grep("Hob_NegTraits",colnames(rawFirst))
# create empty matrices 148 traits causing 8 identities because traits don't cause identities
tAdjMatPI <- as.matrix(cbind(matrix(data=0, ncol=8, nrow=148), tAdjMatP))
tAdjMatNI <- as.matrix(cbind(matrix(data=0, ncol=8, nrow=148), tAdjMatN))
for(i in uIds){
  # subset subject
  subDf <- rawFirst[rawFirst$id==i,]
  # 8 identities causing 148 traits for each valence
  subMatP <- matrix(data = 0, nrow = 8, ncol = 148)
  subMatN <- matrix(data = 0, nrow = 8, ncol = 148)
  identityMat <- get(paste0("subIMat.",i))
  subMatP <- cbind(identityMat, subMatP)
  subMatN <- cbind(identityMat, subMatN)
  # for each identity
  for(c in 1:length(idNames)){
    # extract trait nominations for identity c
    traitsCols <- grep(idNames[c],colnames(rawFirst[idSubs]))
    # first index is pos traits
    posCols <- traitsCols[1]
    # second index is neg traits
    negCols <- traitsCols[2]
    # pos traits for identity
    posCols <- idSubs[posCols]
    # neg traits for identity
    negCols <- idSubs[negCols]
    # split it
    selectWordP <-strsplit(as.character(subDf[,posCols][[1]]),",")
    # all traits need to be pushed up 8 because the matrix contains 8 identities first
    selectWordP <-as.numeric(selectWordP[[1]]) + 8
    # populate with 1s for nominations
    subMatP[c , selectWordP] <- 1
    # do the same for negative
    selectWordN <-strsplit(as.character(subDf[,negCols][[1]]),",") 
    selectWordN <-as.numeric(selectWordN[[1]]) + 8
    subMatN[c , selectWordN] <- 1
  }
  # bind empty matrices so it's 156x156, with empty cells for traits causing identities
  subTPMat <- rbind(subMatP, tAdjMatPI)
  subTNMat <- rbind(subMatN, tAdjMatNI)
  # assign identities as first 8 names and traits as the next 148 names
  colnames(subTPMat) <- c(idNames, posTraits$trait)
  # convert to graph
  subTPGraph <- graph.adjacency(subTPMat)
  # identities causing traits and identities causing identities matrix
  assign(paste0("subTPMat.",i),subTPMat)
  assign(paste0("subTPGraph.",i),subTPGraph)
  # generate identities causing pos traits only (neglect identities to identities)
  subTonlyPMat <- subTPMat
  # empty first matrix of 8x8
  subTonlyPMat[1:8,1:8] <- 0
  assign(paste0("subTonlyPMat.",i),subTonlyPMat)
  subTonlyPGraph <- graph.adjacency(subTonlyPMat)
  assign(paste0("subTonlyPGraph.",i),subTonlyPGraph)
  # generate identities causing pos traits only (neglect identities to identities and traits causing traits... only identities causing traits)
  subItoTonlyPMat <- subTPMat
  subItoTonlyPMat[1:8,1:8] <- 0
  subItoTonlyPMat[9:nrow(subItoTonlyPMat),1:ncol(subItoTonlyPMat)] <- 0
  assign(paste0("subItoTonlyPMat.",i),subItoTonlyPMat)
  subItoTonlyPGraph <- graph.adjacency(subItoTonlyPMat)
  assign(paste0("subItoTonlyPGraph.",i),subItoTonlyPGraph)
  
  # do it again for negative
  colnames(subTNMat) <- c(idNames, negTraits$trait)
  subTNGraph <- graph.adjacency(subTNMat)
  assign(paste0("subTNMat.",i),subTNMat)
  assign(paste0("subTNGraph.",i),subTNGraph)
  subTonlyNMat <- subTNMat
  subTonlyNMat[1:8,1:8] <- 0
  assign(paste0("subTonlyNMat.",i),subTonlyNMat)
  subTonlyNGraph <- graph.adjacency(subTonlyNMat)
  assign(paste0("subTonlyNGraph.",i),subTonlyNGraph)
  subItoTonlyNMat <- subTNMat
  subItoTonlyNMat[1:8,1:8] <- 0
  subItoTonlyNMat[9:nrow(subItoTonlyNMat),1:ncol(subItoTonlyNMat)] <- 0
  assign(paste0("subItoTonlyNMat.",i),subItoTonlyNMat)
  subItoTonlyNGraph <- graph.adjacency(subItoTonlyNMat)
  assign(paste0("subItoTonlyNGraph.",i),subItoTonlyNGraph)
  
  # combine the two matrices (don't repeat identities matrix which is first 8x8)
  subTFMat <- cbind(subMatP, subMatN[1:8, 9:156])
  # bind such that pos traits do not cause identities (148x8 of 0s), pos traits can cause pos traits, and pos traits cannot cause neg traits (148x148 of 0s)
  subTFMat <- rbind(subTFMat, as.matrix(data.frame(matrix(data=0, nrow=148, ncol=8), tAdjMatP, matrix(data=0, nrow=148, ncol=148)) ))
  # bind such that neg traits do not cause identities (148x8 of 0s), neg traits cannot cause pos traits (148x148 of 0s), and neg traits can cause neg traits
  subTFMat <- rbind(subTFMat, as.matrix(data.frame(matrix(data=0, nrow=148, ncol=8), matrix(data=0, nrow=148, ncol=148), tAdjMatN) ))
  colnames(subTFMat) <- c(idNames, posTraits$trait, negTraits$trait)
  subTFGraph <- graph.adjacency(subTFMat)
  assign(paste0("subTFMat.",i),subTFMat)
  assign(paste0("subTFGraph.",i),subTFGraph)
  # create identities to traits only matrix (neglecting identity-identity connections)
  subTonlyFMat <- subTFMat
  subTonlyFMat[1:8,1:8] <- 0
  assign(paste0("subTonlyFMat.",i),subTonlyFMat)
  subTonlyFGraph <- graph.adjacency(subTonlyFMat)
  assign(paste0("subTonlyFGraph.",i),subTonlyFGraph)
  # create identities to traits only matrix (neglecting identity-identity and trait causing trait connections)
  subItoTonlyFMat <- subTFMat
  subItoTonlyFMat[1:8,1:8] <- 0
  subItoTonlyFMat[9:nrow(subItoTonlyFMat),1:ncol(subItoTonlyFMat)] <- 0
  assign(paste0("subItoTonlyFMat.",i),subItoTonlyFMat)
  subItoTonlyFGraph <- graph.adjacency(subItoTonlyFMat)
  assign(paste0("subItoTonlyFGraph.",i),subItoTonlyFGraph)
  
}
```

```{r warning=FALSE}
idDf <- data.frame()
x <- c("subID", "id", "I2Ioutdeg", "I2Iindeg", "I2Ideg", "cI2Tdeg", "cI2Adeg",
      "pI2Tdeg", "pI2Adeg", "nI2Tdeg", "nI2Adeg", "I2Itrans", "I2Ibet", "I2Iclose", "I2Ieigen", "cI2T.Trans",
      "cI2T.Bet", "cI2T.Clos", "cI2A.Trans", "cI2A.Bet", "cI2A.Clos", "pI2T.Trans", "pI2T.Bet", "pI2T.Clos", "pI2A.Trans", "pI2A.Bet", 
      "pI2A.Clos", "nI2T.Trans", "nI2T.Bet", "nI2T.Clos", "nI2A.Trans", "nI2A.Bet", "nI2A.Clos", "idCommNod", "traitCommNod",
      "cI2A.Hub", "cI2T.Hub", "pI2A.Hub", "pI2T.Hub", "nI2A.Hub", "nI2T.Hub")
idToTraitDf <- data.frame()
x2 <- c("subID", "traits", "IdIn")
globalIDDf <- data.frame()
x3 <- c("subID","idEdgT", "density", "idAveDist", "idTrans", "idSW", "idStrengHom","idPosHom", "idStigHom", "idSizSHom", "idSizUHom", "idSizeDHom", "idInclusHom", "idDifferHom", "idInBHom", "idOutBHom", "idInterBHom", "traitCommGlob", "globEff")

for(i in uIds){
  #for(j in 1:length(idNames)){
    subDf <- rawFirst[rawFirst$id==i,]
    
    # identity to identity causing
    curGraph <- get(paste0("subIGraph.",i))
    I2Ioutdeg <- degree(curGraph, mode="out")
    # identity to identity, receiving
    I2Iindeg <- degree(curGraph, mode="in")
    # identity to identity, all
    I2Ideg <- degree(curGraph, mode="all")
    # identity to identity, local trans
    I2Itrans <- transitivity(curGraph, "localundirected")
    # identity to identity, betweenness
    I2Ibet <- betweenness(curGraph, directed = F)
    # identity to identity, closeness
    I2Iclose <- closeness(curGraph, mode = "all", normalized = T)
    # identity to identity, eigen.vector
    I2Ieigen <- eigen_centrality(curGraph, directed = F)$vector
    
    # identity to identity network total edges
    idEdgT <- ecount(curGraph)
    # density
    density <- edge_density(curGraph)
    # average distance
    aveDist <- mean_distance(curGraph)
    # clustering coefficient
    idTrans <- transitivity(curGraph, "global")
    # small worldness
    #idSW <- qgraph::smallworldIndex(curGraph)$index
    idSW <- qgraph::smallworldness(curGraph)[1]
    # global efficiency
    globEff <- brainGraph::efficiency(curGraph, type = "global")
    
    # assortativity of identification
    V(curGraph)$ident <- rawSec[rawSec$id==i, paste0("I_",c("Race","Gender","Sex","Relig","SES","Occup","Hob","Pol"))]
    idStrengHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$ident)+rnorm(1, 0, .00001), directed=F)
    # of positivity
    V(curGraph)$pos <- rawSec[rawSec$id==i, paste0("P_",c("Race","Gender","Sex","Relig","SES","Occup","Hob","Pol"))]
    idPosHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$pos)+rnorm(1, 0, .00001), directed=F)
    # of stigma
    V(curGraph)$Stig <- rawSec[rawSec$id==i, paste0("St_",c("Race","Gender","Sex","Relig","SES","Occup","Hob","Pol"))]
    idStigHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$Stig)+rnorm(1, 0, .00001), directed=F)
    # of size to school
    V(curGraph)$SzS <- rawSec[rawSec$id==i, paste0("Sz_",c("Race","Gender","Sex","Relig","SES","Occup","Hob","Pol"),"_1")]
    idSzSHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$SzS)+rnorm(1, 0, .00001), directed=F)
    # of size to U.S.
    V(curGraph)$SzU <- rawSec[rawSec$id==i, paste0("Sz_",c("Race","Gender","Sex","Relig","SES","Occup","Hob","Pol"),"_13")]
    idSzUHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$SzU)+rnorm(1, 0, .00001), directed=F)
    # of size difference
    V(curGraph)$SzD <- as.numeric(V(curGraph)$SzS) - as.numeric(V(curGraph)$SzU)
    idSzDHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$SzD)+rnorm(1, 0, .00001), directed=F)
    # of inclusion
    V(curGraph)$inclus <- rawSec[rawSec$id==i, paste0("A_",c("Race","Gender","Sex","Relig","SES","Occup","Hob","Pol"))]
    idInclusHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$inclus)+rnorm(1, 0, .00001), directed=F)
    # of differentiation
    V(curGraph)$differ <- rawSec[rawSec$id==i, paste0("D_",c("Race","Gender","Sex","Relig","SES","Occup","Hob","Pol"))]
    idDifferHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$differ)+rnorm(1, 0, .00001), directed=F)
    # of ingroup bias
    V(curGraph)$inb <- rawSec[rawSec$id==i, paste0("Therm_",c("Race","Gender","Sex","Relig","SES","Occup","Hob","Pol"),"_1")]
    idInbHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$inb)+rnorm(1, 0, .00001), directed=F)
    # of outgroup bias
    V(curGraph)$outb <- rawSec[rawSec$id==i, paste0("Therm_",c("Race","Gender","Sex","Relig","SES","Occup","Hob","Pol"),"_2")]
    idOutbHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$outb)+rnorm(1, 0, .00001), directed=F)
    # of intergroup difference
    V(curGraph)$interb <- as.numeric(V(curGraph)$inb) - as.numeric(V(curGraph)$outb)
    idInterbHom <- assortativityNA(curGraph, as.numeric(V(curGraph)$interb)+rnorm(1, 0, .00001), directed=F)
    
    # global similarity of identity network
    idCommGlob <- mean(similarity(curGraph, method = "dice")[1:8,1:8])
    # identity-node similarity
    idCommNod <- rowMeans(similarity(curGraph, method = "dice")[1:8,1:8])
    
    # identity to traits, valence combined
    # use identity to traits only network
    #curGraph <- get(paste0("subTonlyFGraph.",i))
    # use identity to traits only network
    curGraph <- get(paste0("subItoTonlyFGraph.",i))
    cI2Tdeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    cI2T.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    cI2T.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    cI2T.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    cI2T.Hub <- hub_score(curGraph, scale = TRUE)$vector
    # identity to traits and identities, valence combined
    curGraph <- get(paste0("subTFGraph.",i))
    cI2Adeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    cI2A.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    cI2A.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    cI2A.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    cI2A.Hub <- hub_score(curGraph, scale = TRUE)$vector
    
    # global similarity of identity network (traits they have in common)
    traitCommGlob <- mean(similarity(curGraph, method = "dice")[1:8,1:8])
    # identity-node similarity
    traitCommNod <- rowMeans(similarity(curGraph, method = "dice")[1:8,1:8])
    
    # identity to traits, positive
    # use identity to traits only network
    #curGraph <- get(paste0("subTonlyPGraph.",i))
    # use identity to traits only network
    curGraph <- get(paste0("subItoTonlyPGraph.",i))
    pI2Tdeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    pI2T.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    pI2T.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    pI2T.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    pI2T.Hub <- hub_score(curGraph, scale = TRUE)$vector
    # identity to traits and identities, positive
    curGraph <- get(paste0("subTPGraph.",i))
    pI2Adeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    pI2A.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    pI2A.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    pI2A.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    pI2A.Hub <- hub_score(curGraph, scale = TRUE)$vector
    
    # identity to traits, negative
    # use identity to traits and traits to traits network
    #curGraph <- get(paste0("subTonlyNGraph.",i))
    # use identity to traits only network
    curGraph <- get(paste0("subItoTonlyNGraph.",i))
    nI2Tdeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    nI2T.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    nI2T.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    nI2T.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    nI2T.Hub <- hub_score(curGraph, scale = TRUE)$vector
    # identity to traits and identities, negative
    curGraph <- get(paste0("subTNGraph.",i))
    nI2Adeg <- degree(curGraph, mode = "out")
    # identity to traits, identities clustering coefficient
    nI2A.Trans <- transitivity(curGraph, "local")
    # identity to traits, identities closeness
    nI2A.Bet <- betweenness(curGraph, directed = T)
    # identity to traits, identities betweenness
    nI2A.Clos <- closeness(curGraph, mode = "out")
    # identity to traits, identity hub score (is it connected to many connections)
    nI2A.Hub <- hub_score(curGraph, scale = TRUE)$vector
    
    # traits receiving identities
    curGraph <- get(paste0("subItoTonlyFGraph.",i))
    IdIn <- degree(curGraph, mode="in")

    idDf <- rbind(idDf, data.frame(rep(i,8), idNames, I2Ioutdeg[1:8], I2Iindeg[1:8], I2Ideg[1:8], cI2Tdeg[1:8], cI2Adeg[1:8],
                                    pI2Tdeg[1:8], pI2Adeg[1:8], nI2Tdeg[1:8], nI2Adeg[1:8], I2Itrans[1:8], I2Ibet[1:8], I2Iclose[1:8],
                                   I2Ieigen[1:8], cI2T.Trans[1:8], cI2T.Bet[1:8], cI2T.Clos[1:8], cI2A.Trans[1:8], cI2A.Bet[1:8],
                                   cI2A.Clos[1:8], pI2T.Trans[1:8], pI2T.Bet[1:8], pI2T.Clos[1:8], pI2A.Trans[1:8], pI2A.Bet[1:8],
                                   pI2A.Clos[1:8], nI2T.Trans[1:8], nI2T.Bet[1:8], nI2T.Clos[1:8], nI2A.Trans[1:8], nI2A.Bet[1:8],
                                   nI2A.Clos[1:8], idCommNod, traitCommNod, cI2A.Hub[1:8], cI2T.Hub[1:8], pI2A.Hub[1:8],
                                   pI2T.Hub[1:8], nI2A.Hub[1:8], nI2T.Hub[1:8]))
    
    idToTraitDf <- rbind(idToTraitDf, data.frame(subID = rep(i,296), traits = c(posTraits$trait, negTraits$trait), IdIn[9:304] ))
    
    globalIDDf <- rbind(globalIDDf, data.frame(subID = i, idEdgT = idEdgT, idDensity = density, idTrans = idTrans, idSW = idSW, idStrengHom = idStrengHom, idPosHom = idPosHom, idStigHom = idStigHom, idSizeSHom = idSzSHom, idSizeUHom = idSzUHom, idSizeDHom = idSzDHom, idInclusHom = idInclusHom, idDifferHom = idDifferHom, idInbHom = idInbHom, idOutbHom = idOutbHom, idInterbHom = idInterbHom, traitCommGlob = traitCommGlob,idCommGlob=idCommGlob,globEff = globEff))
    
  #}
}
colnames(idDf) <- x
colnames(idToTraitDf) <- x2
```

```{r}
# get list of all adjacency matrices
adjList<-lapply(uIds, function(x) get(paste0("subItoTonlyFMat.",x)))

# subject tendency to nominate traits across all identities
adjListI<-lapply(adjList,'[',1:8,)
sumNomsAcrossIdentities <- lapply(adjListI, function(x) mean(rowSums(x)) )

# trait tendency to be nominated across all 
# adjListT<-lapply(adjList, function(x) x[1:8,9:304])
# sumNomsAcrossTraits <- lapply(adjListT, function(x) colSums(x))
adjListT<-lapply(adjList, function(x) x[1:8,9:304])
sumsAcrossTraits <- lapply(adjListT, function(x) (colSums(x)))
sumNomsAcrossTraits <- colMeans(do.call(rbind, sumsAcrossTraits))

tendSubdDf <- as.data.frame(
  cbind(subID = uIds, 
        subTend = unlist(sumNomsAcrossIdentities)
)
)

tendTraitDf <- as.data.frame(
  cbind(traits = names(sumNomsAcrossTraits), 
        traitTend = unlist(sumNomsAcrossTraits)
)
)
```


```{r}
# traits that are one order distance from identity
traitIdDf1st <- data.frame()
for(i in uIds){
  for(j in 1:length(idNames)){
    subDf <- rawFirst[rawFirst$id==i,]
    
    # traits connected
    curGraph <- get(paste0("subTonlyFGraph.",i))
    traits1st <- ego(curGraph, order = 1, nodes = j, mindist = 1)
    namesTraits <- names(unlist(traits1st))

    traitIdDf1st <- rbind(traitIdDf1st, data.frame(subID = rep(i,length(namesTraits)), id = rep(idNames[j],length(namesTraits)), traits = namesTraits))
  }
}
```

# dataframe of identity ratings

```{r}
idSubs <- grep("I_Race",colnames(rawSec)):grep("Therm_Pol_2",colnames(rawSec),)
idValue <- rawSec[idSubs]
idValue$id <- rawSec$id

longId <- data.frame()
wideId <- data.frame(matrix(nrow=nrow(rawSec)))

#rename(rawSec, ends_with("_1"))

labels <- c("I_","P_","St_","Sz_","Sz_","A_","D_","Therm_","Therm_")

for(k in 1:length(labels)){
  
  if(k==1){
    kc="I_"
    kn="streng"
    sf=""
  }else if(k==2){
    kc="P_"
    kn="pos"
    sf=""
  }else if(k==3){
    kc="St_"
    kn="stig"
    sf=""
  }else if(k==4){
    kc="Sz_"
    kn="sizeS"
    #sf="_1"
    sf=seq(from=1,to=15,by=2)
  }else if(k==5){
    kc="Sz_"
    kn="sizeU"
    sf=seq(from=2,to=16,by=2)
  }else if(k==6){
    kc="A_"
    kn="inclus"
    sf=""
  }else if(k==7){
    kc="D_"
    kn="differ"
    sf=""
  }else if(k==8){
    kc="Therm_"
    kn="inG"
    sf=seq(from=1,to=15,by=2)
  }else if(k==9){
    kc="Therm_"
    kn="outG"
    sf=seq(from=2,to=16,by=2)
  }
  
  kcols <- grep(paste0("^",kc),colnames(rawSec))
  if(length(kcols)>8){
    kcols <- kcols[sf]
  }
  # if(sf!=""){
  #   grep(kco
  # }
  df<-pivot_longer(idValue[c(kcols,grep("id",colnames(idValue)))], cols=starts_with(kc), names_to = c("id"), values_to = kn, names_repair = "unique", names_prefix = kc)
  
  
  
  colnames(df)[1:2] <- c("subID","id")
  
  if(any(k==c(4,5,8,9))){
    df$id <- sub("_[^_]+$", "", df$id)
  }
  
  assign(paste0(kc,"long"),df)
  
  
  if(k>1){
    wideId<-cbind(wideId,idValue[c(kcols)])
  }else{
    wideId<-cbind(wideId,idValue[c(kcols,grep("id",colnames(idValue)))])
  }
  
  if(k==2){
    idLong<-merge(I_long, P_long, by = c("subID","id"))
  }else if(k>2){
    idLong <- merge(idLong, df, by = c("subID","id"))
  }
  
}

# # merge
# idLong <- merge(P_long, M_long, by = c("subID","id"))
# idLong <- merge(idLong, U_long, by = c("subID","id"))
# idLong <- merge(idLong, I_long, by = c("subID","id"))

# fix character string incosistencies
idLong$id<-gsub("Gender","Gen",idLong$id)
idLong$id<-gsub("Relig","Rel",idLong$id)

idLong$interG <- idLong$inG-idLong$outG
idLong$sizeD <- idLong$sizeS - idLong$sizeU
idLong$OD <- idLong$inclus - idLong$differ

# merge with first half identity centrality measures
idLong <- merge(idLong, idDf, by = c("subID","id"))

wideId <-wideId[-1]
wideId <- wideId %>% rename(subID = id) %>% relocate(subID, .before=I_Race)
# wideId <- wideId[c( grep("subID", colnames(wideId)) , 1 : (grep("subID", colnames(wideId))-1) , (grep("subID", colnames(wideId))+1) : ncol(wideId) )]
#test<-pivot_wider(qcidlong, id_cols = id)
#wideId <- merge(wideId, qcidlong, by = "subID")


#wideId<- merge(wideId, qidlong, by = "id")
```

```{r}
traitLong<-pivot_longer(rawSec, cols=Accurate:Worrier, names_to = c("traits"), values_to = "selfResp", names_repair = "unique")
names(traitLong)[colnames(traitLong)=="id"] <- "subID"
traitLong<-traitLong[c("subID","traits","selfResp")]

# convert . to - to match original trait words that are hyphenated
traitLong$traits <- gsub("\\.","-", traitLong$traits)
```

```{r}
fullLong <- merge(traitLong, traitIdDf1st, by = c("subID","traits"))
fullLong[order(fullLong$subID, fullLong$id),]
fullLong <- merge(fullLong, idLong, by = c("subID","id"))
```

# Categorical and Qualitative Identity Kavels

```{r}
# Qualitative identity labels
indcols <- grep(paste0("Q_"),colnames(rawFirst))
qidlong <- pivot_longer(rawFirst[c(indcols,grep("id",colnames(rawFirst)))], cols=starts_with("Q_"), names_to = c("id"), values_to = "idq", names_repair = "unique", names_prefix = "Q_")
colnames(qidlong) <- c("subID","id","idQ")
qidlong$id <- gsub("_4","",qidlong$id)
qidlong$id <- gsub("Hobby", "Hob", qidlong$id)
qidlong$id <- gsub("Relig", "Rel", qidlong$id)
qidlong$id <- gsub("Gender", "Gen", qidlong$id)

# categorical identity labels
#indcols <- grep(paste0("^C_"),colnames(rawFirst)) #& !grepl("_TEXT", colnames(rawFirst))

# extract only C_Anyword ignore _TEXT
indcols <- grep('^(?!.*_TEXT).*C_',colnames(rawFirst), perl = T)
cidlong <- pivot_longer(rawFirst[c(indcols,grep("id",colnames(rawFirst)))], cols=starts_with("C_"), names_to = c("id"), values_to = "idC", names_repair = "unique", names_prefix = "C_")
colnames(cidlong) <- c("subID","id","idC")
cidlong$id <- gsub("_4","",cidlong$id)
cidlong$id <- gsub("Hobby", "Hob", cidlong$id)
cidlong$id <- gsub("Relig", "Rel", cidlong$id)
cidlong$id <- gsub("Gender", "Gen",cidlong$id)

# merge
qcidlong <- merge(cidlong, qidlong, by = c("subID","id"))
```


```{r}
rf <- read.csv("~/Google Drive/Volumes/Research Project/Identities to Traits/Study 2/Cleaning/Input/rawFirst.csv", header = T)
rf <- rf[!as.numeric(duplicated(rf$id)),]

idLabels <- read.csv("~/Google Drive/Volumes/Research Project/Identities to Traits/Study 2/Cleaning/Input/rawFirstQ.csv", header = T)
idLabels <- idLabels[!as.numeric(duplicated(idLabels$id)),]

rf <- merge(rf, idLabels[c("id","C_RaceF","C_GenderF","C_SexF","C_ReligF","C_SESF", "C_OccupF", "C_HobbyF", "C_PolF")])

RaceMatch<-rf[match(unique(rf$RaceC), rf$RaceC), c("C_Race","C_RaceF")]
RaceMatch<-RaceMatch[order(RaceMatch$C_Race),]

SexMatch<-rf[match(unique(rf$SexC), rf$SexC), c("C_Sex","C_SexF")]
SexMatch<-SexMatch[order(SexMatch$C_Sex),]

GenderMatch<-rf[match(unique(rf$GenderC), rf$GenderC), c("C_Gender","C_GenderF")]
GenderMatch<-GenderMatch[order(GenderMatch$C_Gender),]

PolMatch<-rf[match(unique(rf$PolC), rf$PolC), c("C_Pol","C_PolF")]
PolMatch<-PolMatch[order(PolMatch$C_Pol),]

OccupMatch<-rf[match(unique(rf$OccupC), rf$OccupC), c("C_Occup","C_OccupF")]
OccupMatch<-OccupMatch[order(OccupMatch$C_Occup),]

SESMatch<-rf[match(unique(rf$SESC), rf$SESC), c("C_SES","C_SESF")]
SESMatch<-SESMatch[order(SESMatch$C_SES),]

HobbyMatch<-rf[match(unique(rf$HobbC), rf$HobbC), c("C_Hobby","C_HobbyF")]
HobbyMatch<-HobbyMatch[order(HobbyMatch$C_Hobby),]

ReligMatch<-rf[match(unique(rf$ReligC), rf$ReligC), c("C_Relig","C_ReligF")]
ReligMatch<-ReligMatch[order(ReligMatch$C_Relig),]

prop.table(table(rf$RaceC))
prop.table(table(rf$GenderC))
prop.table(table(rf$SexC))
prop.table(table(rf$ReligC))
prop.table(table(rf$SESC))
prop.table(table(rf$PolC))
```

```{r}
RaceMatch$id <- "Race"
GenderMatch$id <- "Gen"
SexMatch$id <- "Sex"
ReligMatch$id <- "Rel"
SESMatch$id <- "SES"
PolMatch$id <- "Pol"
OccupMatch$id <- "Occup"
HobbyMatch$id <- "Hob"

MatchList <- list(RaceMatch,
                  GenderMatch,
                  SexMatch,
                  ReligMatch,
                  SESMatch,
                  PolMatch,
                  OccupMatch,
                  HobbyMatch)
MatchDf <- data.frame()
for(i in MatchList){
  df<-na.omit(i)
  colnames(df) <- c("idC","idCF","id")
  MatchDf <- rbind(MatchDf,df)
}
```


```{r}
fullLong <- merge(fullLong, qcidlong, by = c("subID","id"))
```

# Ind Diff Cleaning

```{r}
indDiff <- rawSec[c(grep("^RSE1$",colnames(rawSec)):grep("^Multiculturalism_2$",colnames(rawSec)), grep("^id$",colnames(rawSec)) )]
indDiff$check4 <- NULL
```

## Need for Cognition

```{r}
NFCrevcols = c("NFC.6_3", "NFC.6_4")
indDiff[ ,NFCrevcols] = 8 - indDiff[ ,NFCrevcols]
ind1 <- grep("NFC.6_1", colnames(indDiff))
ind1<-min(ind1)
ind2<- grep("NFC.6_6", colnames(indDiff))
ind2<-max(ind2)
# Compute scores for Need for Cog
indDiff$NFC = rowMeans(indDiff[, ind1:ind2], na.rm = TRUE)

psych::alpha(indDiff[ind1:ind2])
```

## Self-Esteem

```{r}
# Reverse code Rosenberg Self-Esteem items
SErevcols = c("RSE2", "RSE5", "RSE6", "RSE8", "RSE9")
indDiff[ ,SErevcols] = 5 - indDiff[ ,SErevcols]
ind1 <- grep("^RSE1$", colnames(indDiff))
ind1<-min(ind1)
ind2<- grep("^RSE10$", colnames(indDiff))
ind2<-max(ind2)
# Compute scores for Rosenberg Self-Esteem
indDiff$SE = rowMeans(indDiff[, ind1:ind2], na.rm = TRUE)
indDiff$SE <- 5 - indDiff$SE
psych::alpha(indDiff[ind1:ind2])
```

## Collective Self-Esteem

```{r}
attach(indDiff)
# Reverse code Collective Self-Esteem items (2, 4, 5, 7, 10 ,12, 13, 15)
CSErevcols = c("CSE2", "CSE4", "CSE5", "CSE7", "CSE10", "CSE12", "CSE13", "CSE15")
indDiff[ ,CSErevcols] = 8 - indDiff[ ,CSErevcols]
# Compute score for Membership Self-Esteem
MemSEcols = c("CSE1", "CSE5", "CSE9", "CSE10")
indDiff$MemSE = rowMeans(indDiff[, MemSEcols], na.rm = TRUE)
psych::alpha(indDiff[,MemSEcols])
# Compute score for Private Collective Self-Esteem
PrivCSEcols = c("CSE2", "CSE6", "CSE10", "CSE14")
indDiff$PrivCSE = rowMeans(indDiff[, PrivCSEcols], na.rm = TRUE)
psych::alpha(indDiff[,PrivCSEcols])
# Compute score for Public Collective Self-Esteem
PubCSEcols = c("CSE3", "CSE7", "CSE11", "CSE15")
indDiff$PubCSE = rowMeans(indDiff[, PubCSEcols], na.rm = TRUE)
psych::alpha(indDiff[,PubCSEcols])
# Compute score for Importance to Identity
IdImpcols = c("CSE4", "CSE8", "CSE12", "CSE16")
indDiff$IdImp = rowMeans(indDiff[, IdImpcols], na.rm = TRUE)
psych::alpha(indDiff[,IdImpcols])
```

## Dialectical Self-Views

```{r}
# Reverse code Need for Cog items
#DSrevcols = c("DS_2", "DS_5", "DS_6", "DS_12", "DS_13", "DS_15", "DS_16")
#DSrevcols = c("DS_5", "DS_7", "DS_8", "DS_13", "DS_15", "DS_16")
#DSrevcols = c("DS_2", "DS_6", "DS_10", "DS_12", "DS_17")
# reverse score 1, 5, 6, 7, 9, 14

columnNames <- colnames(indDiff[grep("^DS",colnames(indDiff))])
DSrevcols <- columnNames[c(1,5,6,7,9,14)]
#DSrevcols = c("DS_1", "DS_7", "DS_8", "DS_9", "DS_11","DS_17")
indDiff[ ,DSrevcols] = 8 - indDiff[ ,DSrevcols]
ind1 <- grep("DS_1", colnames(indDiff))
ind1<-min(ind1)
ind2<- grep("DS_14", colnames(indDiff))
ind2<-max(ind2)
# Compute scores for Need for Cog
indDiff$DS = rowMeans(indDiff[, ind1:ind2], na.rm = TRUE)

psych::alpha(indDiff[ind1:ind2])
```

## Self-Concept Clarity

```{r}
# Reverse code Self-Concept Clarity Scale items
SCC_revcols = c("SCC1", "SCC2", "SCC3", "SCC4", "SCC5", "SCC7", 
                 "SCC8", "SCC9", "SCC10", "SCC12")
indDiff[ ,SCC_revcols] = 6 - indDiff[ ,SCC_revcols]
ind1 <- grep("SCC1", colnames(indDiff))
ind1<-min(ind1)
ind2<- grep("SCC12", colnames(indDiff))
ind2<-max(ind2)
# Compute score for Self-Concept Clarity Scale items
indDiff$SCC = rowMeans(indDiff[,ind1:ind2], na.rm = TRUE)

psych::alpha(indDiff[ind1:ind2])
```

## Satisfaction with Life

```{r}
ind1 <- grep("SWLS_1", colnames(indDiff))
ind1<-min(ind1)
ind2<- grep("SWLS_5", colnames(indDiff))
ind2<-max(ind2)
# Compute score for Self-Concept Clarity Scale items
indDiff$SWLS = rowMeans(indDiff[,ind1:ind2], na.rm = TRUE)

psych::alpha(indDiff[ind1:ind2])
```

## CESD

```{r}
# Reverse code Self-Concept Clarity Scale items
CESD_revcols = c("CESD4", "CESD8", "CESD12", "CESD16")
indDiff[ ,CESD_revcols] = 5 - indDiff[ ,CESD_revcols]
ind1 <- grep("CESD", colnames(indDiff))
ind1<-min(ind1)
ind2<- grep("CESD", colnames(indDiff))
ind2<-max(ind2)
# Compute score for Self-Concept Clarity Scale items
indDiff$CESD = rowMeans(indDiff[,ind1:ind2], na.rm = TRUE)

psych::alpha(indDiff[ind1:ind2])
```

## Singelis Self-Construal

```{r}
# Compute score for Independent
Indcols = c("Sing1", "Sing2", "Sing5", "Sing7", "Sing9", "Sing10", "Sing13", "Sing15", "Sing18", "Sing20", "Sing22", "Sing24", "Sing25", "Sing27", "Sing29")
indDiff$Ind = rowMeans(indDiff[, Indcols], na.rm = TRUE)
psych::alpha(indDiff[,Indcols])
# Compute score for Interdependent
Indcols = c("Sing3", "Sing4", "Sing6", "Sing8", "Sing11", "Sing12", "Sing14", "Sing16", "Sing17", "Sing19", "Sing21", "Sing23", "Sing26", "Sing28", "Sing30")
indDiff$Inter = rowMeans(indDiff[, Indcols], na.rm = TRUE)
psych::alpha(indDiff[,Indcols])
```
# IMS and EMS

```{r}
# Compute score for Independent
inds <- grep("^EMS",colnames(indDiff))
indDiff$EMS = rowMeans(indDiff[, inds], na.rm = TRUE)
psych::alpha(indDiff[,inds])

inds <- grep("^IMS",colnames(indDiff))
indDiff$IMS = rowMeans(indDiff[, inds], na.rm = TRUE)
psych::alpha(indDiff[,inds])
```
# Multiculturalism

```{r}
indDiff$Multiculturalism_2 <- 11-indDiff$Multiculturalism_2
indDiff$MC <- rowMeans(indDiff[,c("Multiculturalism_1","Multiculturalism_2")])
psych::alpha(indDiff[,c("Multiculturalism_1","Multiculturalism_2")])
```

# Self-Complexity Scores

```{r}
library(selfcomplexity)
selfcomplexityDf <- traitIdDf1st %>%
  group_by(subID, id) %>%
  summarize(att = paste(traits, collapse = ','))

HScores<-calculate_H(data=as.tibble(selfcomplexityDf),att_column = "att", id_column = "subID", vector = c(posTraits$trait,negTraits$trait))

OverlapScores<-calculate_overlap(data=as.tibble(selfcomplexityDf), att_column="att", subtype_column = "id", id_column = "subID")

PhiScores<-calculate_phi(data=as.tibble(selfcomplexityDf),att_column = "att", id_column = "subID", pos_att_vector = posTraits$trait, neg_att_vector =  negTraits$trait)

SCdf <- merge(HScores, OverlapScores, by = "subID")
SCdf <- merge(SCdf, PhiScores, by = "subID")
```


```{r}
colnames(indDiff)[colnames(indDiff)=="id"] <- "subID"
indDiff <- merge(indDiff, SCdf, by = "subID")
fullLong <- merge(fullLong, indDiff[c("subID","SE","SCC","NFC","Ind","Inter","SWLS","DS","MemSE","PrivCSE","PubCSE","IdImp","CESD","IMS","EMS","MC")], by = "subID", all.x=T)
fullLong <- merge(fullLong, globalIDDf, by = "subID", all.x = T)
```

# generate dataframe for semantic distance from identity

```{r}
identities <- colnames(subTFMat)[1:8]
traits <- colnames(subTFMat)[9:304]
distMatText <- matrix(nrow=296*length(uIds)*8,ncol=3)
distMatNum <- matrix(nrow=296*length(uIds)*8,ncol=6)
#idToSimMat <- matrix(nrow = 0, ncol = 5)
iterator1 <- 1
iterator2 <- (296*8)
for(n in 1:length(uIds)){
  i <- uIds[n]
  evals <- rep(traitLong$selfResp[traitLong$subID==i],8)
  curGraph1 <- get(paste0("subTonlyFGraph.",i))
  distMatT <- distances(curGraph1, mode = "all")[1:8,9:304]
  distT <- c(t(distMatT))
  distMatO <- distances(curGraph1, mode = "out")[1:8,9:304]
  distO <- c(t(distMatO))
  
  curGraph1 <- get(paste0("subTFGraph.",i))
  curGraph2 <- get(paste0("subTonlyFGraph.",i))
  simsMat1 <- similarity.dice(curGraph1)[1:8,9:304]
  IT.Sim <- c(t(simsMat1))
  simsMat2 <- similarity.dice(curGraph2)[1:8,9:304]
  T.Sim <- c(t(simsMat2))
  
  block1 <- cbind(rep(i, 8*296), evals, distT, distO, IT.Sim, T.Sim)
  block2 <- cbind(rep(traits,8), rep(c(rep("positive",148),rep("negative",148)),8),
                  rep(identities, each=296))
  
  distMatText[iterator1:iterator2, 1:ncol(block2)] <- block2
  distMatNum[iterator1:iterator2, 1:ncol(block1)] <- block1
  
  iterator1 <- iterator1+(296*8)
  iterator2 <- iterator1+((296*8)-1)
}
orderDf <- cbind(as.data.frame(distMatText), as.data.frame(distMatNum))
colnames(orderDf) <- c("traits","valence","id","subID","selfResp","order","orderO", "IT.Sim", "T.Sim")
orderDf <- as.data.frame(orderDf)


orderDf <- orderDf[order(orderDf$subID, orderDf$order),]
orderDf <- merge(orderDf, qcidlong, by = c("subID","id"))
orderDf <- merge(orderDf, idLong, by = c("subID","id"))
orderDf <- merge(orderDf, indDiff[c("subID","SE","SCC","NFC","Ind","Inter","SWLS","DS","MemSE","PrivCSE","PubCSE","IdImp","CESD")], by = "subID")
orderDf <- merge(orderDf, globalIDDf, by = "subID", all.x = T, all.y=T)

orderDf$order[is.infinite(orderDf$order)] <- NA
orderDf$orderO[is.infinite(orderDf$orderO)] <- NA

cur<-orderDf[, c("order","T.Sim")]
PCAall<- prcomp(na.omit(cur),
             center = TRUE,
            scale. = TRUE)
orderDf$PCAdist[!is.na(orderDf$order) & !is.na(orderDf$T.Sim)] <- PCAall$x[,1]
```

```{r}
uSub<-unique(fullLong$subID)
uId<-unique(fullLong$id)
# nrow(fullLong)
# test<-fullLong[fullLong$id %in% as.array(uId), ]
# test<-subset(fullLong, subID==uSub & id==uId)

idShort <- merge(idLong, qcidlong, by = c("subID","id"))
idShort <- merge(idShort, indDiff[c("subID","SE","SCC","NFC","Ind","Inter","SWLS","DS","MemSE","PrivCSE","PubCSE","IdImp","CESD")], by = c("subID"))
idShort <- merge(idShort, globalIDDf, by = "subID", all.x = T)
for(i in uSub){
  for(j in uId){
    idShort$sdSR[idShort$subID==i & idShort$id==j] <- sd(fullLong$selfResp[fullLong$subID==i & fullLong$id==j],na.rm=T)
  }
}
```

```{r}
fullLong <- merge(fullLong, idToTraitDf, by = c("subID","traits"))
```

```{r}
traits<-rbind(posTraits, negTraits)
traits$Idx <- 1:296
colnames(traits)[colnames(traits)=="trait"] <- "traits"
fullLong <- merge(fullLong, traits, by = "traits")
orderDf <- merge(orderDf, traits, by = c("traits","valence"))
```

```{r}
indDiffSmall <- merge(indDiff[c("subID","SE","SCC","NFC","Ind","Inter","SWLS","DS","MemSE","PrivCSE","PubCSE","IdImp","CESD","IMS","EMS","MC", "H_index", "overlap_norm", "phi")], globalIDDf, by = "subID")
```



```{r}
uIds <- unique(idShort$subID)
uId <- unique(idShort$id)

#fullSimDf <- matrix(ncol=6, nrow=8*length(uIds))
fullSimDf <- data.frame()

for(i in uIds){
    #subDf <- rawFirst[rawFirst$id==i,]
    subDf <- idShort[idShort$subID==i,]
  
    # identity to identity causing
    curGraph <- get(paste0("subIGraph.",i))
    
    # identity to all traits graph
    curGraphItoT <- get(paste0("subItoTonlyFGraph.",i))
    
    # identity to pos traits graph
    curGraphItoT.p <- get(paste0("subItoTonlyPGraph.",i))
    
    # identity to neg traits graph
    curGraphItoT.n <- get(paste0("subItoTonlyNGraph.",i))
    
    sim=similarity.dice(curGraph)
    simVect=sim[lower.tri(sim)==T]
    if(length(simVect)<28){
      break
    }
    
    # Dice Similarity in All Shared Traits
    simIT=similarity.dice(curGraphItoT)
    simIT=simIT[1:8,1:8]
    simVectIT=simIT[lower.tri(simIT)==T]
    if(length(simVectIT)<28){
      break
    }
    
    # Dice SimilarIy in All Shared TraIT.ps
    simIT.p=similarity.dice(curGraphItoT.p)
    simIT.p=simIT.p[1:8,1:8]
    simVectIT.p=simIT.p[lower.tri(simIT.p)==T]
    if(length(simVectIT.p)<28){
      break
    }
    
    # Dice Similarity in Neg Shared Traits
    simIT.n=similarity.dice(curGraphItoT.n)
    simIT.n=simIT.n[1:8,1:8]
    simVectIT.n=sim[lower.tri(simIT.n)==T]
    if(length(simVectIT.n)<28){
      break
    }
    
    # distance of positivity
    posVect <- as.vector(dist(idShort$pos[idShort$subID==i]))
    if(length(posVect)<28){
      break
    }
    # distance of identification
    strengVect <- as.vector(dist(idShort$streng[idShort$subID==i]))
    if(length(strengVect)<28){
      break
    }
    # distance of stigma
    stigVect <- as.vector(dist(idShort$stig[idShort$subID==i]))
    if(length(stigVect)<28){
      break
    }
    # distance of size school
    sizeSVector <- as.vector(dist(idShort$sizeS[idShort$subID==i]))
    if(length(sizeSVector)<28){
      break
    }
    # distance of size school
    sizeUVector <- as.vector(dist(idShort$sizeU[idShort$subID==i]))
    if(length(sizeUVector)<28){
      break
    }
    inclusVector <- as.vector(dist(idShort$inclus[idShort$subID==i]))
    if(length(inclusVector)<28){
      break
    }
    differVector <- as.vector(dist(idShort$differ[idShort$subID==i]))
    if(length(differVector)<28){
      break
    }
    inGVector <- as.vector(dist(idShort$inG[idShort$subID==i]))
    if(length(inGVector)<28){
      break
    }
    outGVector <- as.vector(dist(idShort$outG[idShort$subID==i]))
    if(length(outGVector)<28){
      break
    }

    
    curSimDf <- cbind(subID = rep(i,length(simVect)), pair = 1:28, idSim = simVect, idtSim = simVectIT, idtpSim = simVectIT.p, idtnSim = simVectIT.n, posDist = posVect, strengDist = strengVect, stigDist = stigVect, sizeSDist = sizeSVector, sizeUDist = sizeUVector, inclusDist = inclusVector, differDist = differVector, inGVDist = inGVector, outGDist = outGVector)
    
    
    if(any(apply(curSimDf, 2, length)!=28)){
      break
    }
    
    fullSimDf <- rbind(fullSimDf, curSimDf)
    
}
fullSimDf <- merge(fullSimDf, indDiffSmall, by="subID")
```


```{r}
netWide <- pivot_wider(idShort[c("subID","id","I2Ideg","cI2Tdeg","pI2Tdeg","nI2Tdeg","idCommNod","traitCommNod")], values_from = c(I2Ideg, cI2Tdeg, pI2Tdeg, nI2Tdeg, idCommNod, traitCommNod), names_from = id)
wideId <- merge(wideId, netWide, by = "subID")
```

```{r}
idNames <- c("Race","Gen","Sex","Rel","SES","Pol","Occup","Hob")
veryLong <- merge(traitLong, idLong, by = "subID")
traits$Idx <- 1:296
veryLong <- merge(veryLong, traits, by.x = "traits", by = "traits")
veryLong <- veryLong[order(veryLong$subID, veryLong$Idx),]
veryLong$connect <- 0
for(i in unique(veryLong$subID)){
  for(j in 1:length(idNames)){
    curMat <- get(paste0("subTFMat.",i))
    veryLong$connect[veryLong$subID==i & veryLong$id==idNames[j]] <- as.numeric(curMat[j,9:304])
    #which(veryLong$traits[veryLong$subID==i & veryLong$id==j]==traitIdDf1st$traits[veryLong$subID==i & veryLong$id==j])
  }
}

fullLong2 <- subset(veryLong, connect == 1)
veryLong <- merge(veryLong, qcidlong, by = c("subID","id"))
veryLong <- merge(veryLong, indDiff[c("subID","SE","SCC","NFC","Ind","Inter","SWLS","DS","MemSE","PrivCSE","PubCSE","IdImp","CESD")], by = "subID", all.x=T)
veryLong <- merge(veryLong, globalIDDf, by = "subID", all.x = T)
veryLong <- merge(veryLong, idToTraitDf, by = c("subID","traits"))
```

```{r}
veryLong <- merge(veryLong, tendSubdDf, by = "subID", all.x=T)
orderDf <- merge(orderDf, tendSubdDf, by = "subID", all.x=T)
idShort <- merge(idShort, tendSubdDf, by = "subID", all.x=T)
indDiffSmall <- merge(indDiffSmall, tendSubdDf, by = "subID", all.x=T)
fullSimDf <- merge(fullSimDf, tendSubdDf, by = "subID", all.x=T)


veryLong <- merge(veryLong, tendTraitDf, by = "traits", all.x=T)
orderDf <- merge(orderDf, tendTraitDf, by = "traits", all.x=T)
```

```{r}
#write.csv(fullLong, "~/Google Drive/Volumes/Research Project/Identities to Traits/Study 2/Cleaning/Output/id2traitDf.csv", row.names = F)
write.csv(demos, "~/Google Drive/Volumes/Research Project/Identities to Traits/Study 2/Cleaning/Output/demos.csv", row.names = F)
write.csv(veryLong, "~/Google Drive/Volumes/Research Project/Identities to Traits/Study 2/Cleaning/Output/id2traitDf.csv", row.names = F)
write.csv(orderDf, "~/Google Drive/Volumes/Research Project/Identities to Traits/Study 2/Cleaning/Output/orderDf.csv", row.names = F)
write.csv(idShort, "~/Google Drive/Volumes/Research Project/Identities to Traits/Study 2/Cleaning/Output/id2traitShort.csv", row.names = F)
write.csv(indDiffSmall, "~/Google Drive/Volumes/Research Project/Identities to Traits/Study 2/Cleaning/Output/indDiff.csv", row.names = F)
write.csv(fullSimDf, "~/Google Drive/Volumes/Research Project/Identities to Traits/Study 2/Cleaning/Output/identitySimDf.csv", row.names = F)
write.csv(wideId, "~/Google Drive/Volumes/Research Project/Identities to Traits/Study 2/Cleaning/Output/idWide.csv", row.names = F)
save.image("~/Google Drive/Volumes/Research Project/Identities to Traits/Study 2/Cleaning/Output/id2traitsworkspace.RData")
```












